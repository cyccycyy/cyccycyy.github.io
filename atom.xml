<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cyy的个人记录</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-10T11:21:26.111Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>cyy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS106L</title>
    <link href="http://example.com/2023/06/10/CS106L-0/"/>
    <id>http://example.com/2023/06/10/CS106L-0/</id>
    <published>2023-06-10T06:15:14.970Z</published>
    <updated>2023-06-10T11:21:26.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>​最近想做CMU 15-445，但是因为好久没写C++了，语法全忘完了，直接边学课程边回忆语法的话又没信心，干脆找了这门CS106L课程来复习C++。</p><p>​大致看了一下课程大纲，还是能够比较全面的复习到C++知识点的。因为这门课体量比较小，就直接使用一篇笔记来记录了。</p><p>​开搞！</p><p>​<a href="http://web.stanford.edu/class/cs106l/index.html">课程官网</a></p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>​我的电脑装的是win11，但是大多数服务器装的都是linux系统，所以我打算使用vscode + wsl2的方式来学习这门课。这门课的assignments 0介绍了使用vscode进行c++开发需要的基本步骤(setup)。</p><h2 id="1-Welcome"><a href="#1-Welcome" class="headerlink" title="1. Welcome!"></a>1. Welcome!</h2><ul><li>课程开设时，C++版本为20。</li><li>C++: Basic Syntax + the STL。</li></ul><h2 id="2-Types-and-Structs"><a href="#2-Types-and-Structs" class="headerlink" title="2. Types and Structs"></a>2. Types and Structs</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul><li>不使用<code>using namespace std;</code></li><li>The namespace for the STL is std.</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>int - 32 bits</li><li>char - 8 bits (usually)</li><li>float - 32 bits</li><li>double - 64 bits</li><li>bool - 1 bit</li></ul><h3 id="C-是静态类型语言"><a href="#C-是静态类型语言" class="headerlink" title="C++是静态类型语言"></a>C++是静态类型语言</h3><ul><li><p>编译型 VS 解释型</p><ul><li>主要区别：源代码什么时候被翻译<ul><li>源代码：代码本身</li><li>翻译：将源代码转换成计算机可以理解的某种东西</li></ul></li><li>解释型语言在运行时一行一行的被解释。(Python)</li><li>编译型语言在运行前统一翻译(C++)</li><li>静态类型帮助我们在代码运行前预防错误</li></ul></li><li><p>函数重载 - 参数不同的多个同名函数</p></li></ul><h3 id="struct-一组拥有自己的名字的变量，可以将不同类型绑定到一起"><a href="#struct-一组拥有自己的名字的变量，可以将不同类型绑定到一起" class="headerlink" title="struct - 一组拥有自己的名字的变量，可以将不同类型绑定到一起"></a>struct - 一组拥有自己的名字的变量，可以将不同类型绑定到一起</h3><pre><code class="c++">struct Student &#123;    string name; // these are called fields    string state; // separate these by semicolons    int age;&#125;;</code></pre><ul><li><p>使用”.”来访问字段</p></li><li><p>初始化struct的简单语法：</p><pre><code class="c++">Student s;s.name = &quot;Sarah&quot;;s.state = &quot;CA&quot;;s.age = 21;//is the same as ...Student s = &#123;&quot;Sarah&quot;, &quot;CA&quot;, 21&#125;;</code></pre></li><li><p>std::pair - 一个STL内置结构体，带有两个字段，两个字段可以是任何类型。</p><ul><li><p>std::pair是一个模板</p></li><li><p>使用make_pair来创造pair</p><pre><code class="c++">return std::make_pair(true, result);</code></pre></li></ul></li><li><p>auto(关键词) - 类型推断</p><ul><li>使用auto不代表变量没有类型，而是代表变量类型由编译器推导。、</li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>程序中<strong>每一个</strong>有名字的东西都有它的类型</p></li><li><p>静态类型在代码运行前预防错误</p></li><li><p>结构体是一种将多个变量捆绑到一起的方式</p></li><li><p>std::pair是一种已经在STL中定义的结构体，可以通过std:: 命名空间访问</p></li><li><p>auto是一个关键字，用于告诉编译器让它推断一个变量的类型。在类型很明显或者类型写出来很麻烦时使用</p></li><li><p>quadratic.cpp</p><pre><code>#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cmath&gt; //gives us pow and sqrt!using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;using std::pow;using std::sqrt;using std::string;// want: a function named quadratic that will take in 3 doubles and return// a combination of: does a solution exist, and if so, what is it?// get radical, test if negative, return indicating no roots//  radical = b^2 - 4ac// otherwise get roots and return//  root1 = (-b + sqrt(radical)) divided by 2a//  root2 = (-b - sqrt(radical)) divided by 2apair&lt;bool, pair&lt;double, double&gt;&gt; quadratic(double a, double b, double c)&#123;    double radical = pow(b, 2.0) - 4 * a * c;    if (radical &lt; 0)    &#123;        return make_pair(false, make_pair(0, 0));    &#125;    double root1 = (-b + sqrt(radical)) / (2 * a);    double root2 = (-b - sqrt(radical)) / (2 * a);    return make_pair(true, make_pair(root1, root2));&#125;int main()&#123;    // get 3 doubles (ax^2 + bx + c)    double a, b, c;    cout &lt;&lt; &quot;Give me 3 coefficients: &quot; &lt;&lt; endl;    // This line gets 3 numbers from user input and stores them in a, b and c    // we will learn more about cin on Thursday    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    // some call to quadratic function!    auto res = quadratic(a, b, c);    bool flag = res.first;    // get roots if they exist    if (!flag)    &#123;        cout &lt;&lt; &quot;No solution!&quot;;        return 0;    &#125;    double r1 = res.second.first;    double r2 = res.second.second;    // print accordingly    cout &lt;&lt; &quot;root1: &quot; &lt;&lt; r1 &lt;&lt; &quot; root2: &quot; &lt;&lt; r2;    return 0;&#125;// Test: x^2 + 5x + 6 = 0, roots = -3, -2// To run: first compile code --&gt; make quadratic,// then run the compiled code --&gt; ./quadratic</code></pre></li></ul><h2 id="3-Initialization-and-References"><a href="#3-Initialization-and-References" class="headerlink" title="3. Initialization and References"></a>3. Initialization and References</h2><h3 id="Initialization-为变量提供初始值"><a href="#Initialization-为变量提供初始值" class="headerlink" title="Initialization - 为变量提供初始值"></a>Initialization - 为变量提供初始值</h3><ul><li><p>uniform initialization: 花括号初始化，对所有类型可用，在声明时立即初始化</p><ul><li><p>初始化vector时要小心</p><pre><code class="cpp">std::vector&lt;int&gt; vec1(3,5);// makes &#123;5, 5, 5&#125;, not &#123;3, 5&#125;!// uses a std::initializer_list (more later)std::vector&lt;int&gt; vec2&#123;3,5&#125;;// makes &#123;3, 5&#125;</code></pre></li><li><p><strong>使用统一初始化来初始化你的每一个非主类型字段</strong></p></li></ul></li></ul><h3 id="use-auto"><a href="#use-auto" class="headerlink" title="use auto"></a>use auto</h3><ul><li><p>不要过度使用auto - 简单类型直接写出来</p></li><li><p>Structured Binding</p><ul><li><p>Before</p><pre><code class="c++">auto p =std::make_pair(“s”, 5);string a = p.first;int b = p.second;</code></pre></li><li><p>After</p><pre><code class="c++">auto p = std::make_pair(“s”, 5);auto [a, b] = p;// a is string, b is int// auto [a, b] =std::make_pair(...);</code></pre></li><li><p>cleaner quadratic</p><pre><code class="c++">auto [found, solutions] = quadratic(a, b, c);</code></pre></li></ul></li></ul><h3 id="references-一个带名变量的别名"><a href="#references-一个带名变量的别名" class="headerlink" title="references - 一个带名变量的别名"></a>references - 一个带名变量的别名</h3><ul><li><p>经典的引用-拷贝bug 1.0：</p><pre><code class="c++">void shift(vector&lt;std::pair&lt;int, int&gt;&gt;&amp; nums) &#123;    for (size_t i = 0; i &lt; nums.size(); ++i) &#123;        auto [num1, num2] = nums[i];        num1++;        num2++;    &#125;&#125;//修正//auto [num1, num2] = nums[i]; -&gt; auto&amp; [num1, num2] = nums[i];</code></pre><ul><li>size_t 常被用于索引，因为它是无符号的并且有着动态的大小</li><li>++i 和 i++ 不再有性能区别</li></ul></li><li><p>经典的引用-拷贝bug 2.0：</p><pre><code class="c++">void shift(vector&lt;std::pair&lt;int, int&gt;&gt;&amp; nums) &#123;    for (auto [num1, num2]: nums) &#123;        num1++;        num2++;    &#125;&#125;//修正//auto [num1, num2]: nums -&gt; auto&amp; [num1, num2]: nums</code></pre></li><li><p>l-values vs r-values</p><ul><li><p>l-values 可以出现在<strong>赋值号</strong>左边或右边， l-values不是临时的</p><pre><code>int x = 3;//x is a l-valueint y = x;</code></pre></li><li><p>r-values 只能出现在等号右边，r-values是临时的</p><pre><code>int x = 3;//3 is a r-valueint y = x;</code></pre></li></ul></li></ul><h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><ul><li>Const and Const References<ul><li>const表明一个变量不能被修改，const变量<strong>可以</strong>被引用</li></ul></li><li>当我们进行变量赋值时，C++默认情况下会进行拷贝。如果需要引用就使用&amp;<ul><li>如果对一个几乎不占空间的变量进行操作，不需要使用引用，直接拷贝变量就好</li><li>如果我们需要为变量起别名来修改变量，可以使用引用</li><li>如果不需要修改变量，但是变量很占空间，可以使用const引用</li></ul></li></ul><h2 id="4-Streams"><a href="#4-Streams" class="headerlink" title="4. Streams"></a>4. Streams</h2><h3 id="What-are-streams"><a href="#What-are-streams" class="headerlink" title="What are streams?"></a>What are streams?</h3><ul><li><p>definition</p><p>stream: 对I&#x2F;O的一个抽象。流对数据和数据的串表示进行相互转换。</p></li><li><p>std::cout是一个输出流，它有着std::ostream类型</p></li><li><p>流的分类</p><p><img src="/../images/CS106L/4.1.%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="流的分类"></p></li></ul><h3 id="Output-streams"><a href="#Output-streams" class="headerlink" title="Output streams"></a>Output streams</h3><ul><li>类型为std::ostream</li><li>只能发送数据到流</li><li>std::cout是一个全局常量对象</li><li>ofstream</li></ul><h3 id="Input-streams"><a href="#Input-streams" class="headerlink" title="Input streams"></a>Input streams</h3><ul><li><p>“&gt;&gt;”是流提取操作符，用于从一个流中提取数据并把数据放到变量中</p></li><li><p>“&lt;&lt;”是流插入操作符，用来插入数据到流中</p></li><li><p>类型为std::istream</p></li><li><p>输入流接收到错误的数据（例如数据类型不匹配）</p><p>一旦一个错误被检测到，输入流的fail bit会被设置，它就不会再接收输入。</p></li><li><pre><code class="c++">istream&amp; getline(istream&amp; is, string&amp; str, char delim);</code></pre></li><li><p><strong>重要提示</strong>：不要将”&gt;&gt;”和getline混用！</p><ul><li>“&gt;&gt;”读取下一个空白符之前的内容，不会跳过空白符</li><li>“getline”读取下一个界定符前的内容，并且会跳过界定符</li></ul></li><li><p>ifstream</p></li><li><p>std::cin是一个全局常量对象</p></li></ul><h3 id="String-streams"><a href="#String-streams" class="headerlink" title="String streams!"></a>String streams!</h3><ul><li>Stringstream是一个流，可以从一个string对象中读取数据或者向string对象写入数据。</li><li>只读流：istringstream</li><li>只写流：ostringstream</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;​	最近想做CMU 15-445，但是因为好久没写C++了，语法全忘完了，直接边学课程边回忆语法的话又没信心，干脆找了这门CS106L课程来</summary>
      
    
    
    
    
    <category term="国外计算机课程" scheme="http://example.com/tags/%E5%9B%BD%E5%A4%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="Cpp" scheme="http://example.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>记一次关于TreeMap的使用的坑</title>
    <link href="http://example.com/2023/06/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ETreeMap%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/"/>
    <id>http://example.com/2023/06/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ETreeMap%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/</id>
    <published>2023-06-09T06:56:42.089Z</published>
    <updated>2023-06-09T07:27:13.922Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做《牛客算法必刷101》的最后一题时遇到了一个坑。原题目这里就不赘述了，原题目地址：</p><p><a href="https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295&tqId=1006014&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295&amp;tqId=1006014&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj</a></p><p>定义<code>TreeMap&lt;int[], Integer&gt; orderedMap </code>,要求orderedMap（下文简称map）的键长度为3，并且给出map的完整定义：</p><pre><code class="java">private TreeMap&lt;int[], Integer&gt; orderedMap = new TreeMap&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;    @Override    public int compare(int[] a, int[] b) &#123;        //如果调用次数不等，次数少的排在前面        if (a[1] != b[1])            return a[1] - b[1];        //如果调用次数相等，调用时间早的排在前面        return a[2] - b[2];    &#125;&#125;);</code></pre><p>这里我想表达的是：对于map中的两个键，如果一个键的第二个元素小于另一个键的第二个元素，那么这个键排在另一个键的前面；如果这两个键相等，那么键的第三个元素小的排前面。</p><p>现在假设map中现有几个元素</p><pre><code class="java">[1, 1, 0] -&gt;  1[4, 2, 4] -&gt;  4[3, 2, 5] -&gt;  3[2, 2, 6] -&gt;  2</code></pre><p>可以看到现在map中元素的顺序是正确的，如果我用一个变量data记录了map中的第一个键，就像这样（实际我的代码中是通过其它方式获得这个键的，这里为了简洁就直接从map中获得了）：</p><pre><code class="java">int[] data = orderedMap.firstKey();</code></pre><p>现在如果我通过data修改数组为[1,2,7]：</p><pre><code class="java">data[1] = 2;data[2] = 7;</code></pre><p>然后我将data从map中删除，然后再将data添加到map中不就可以保持map中的元素有序了吗？</p><pre><code class="java">orderedMap.remove(data);orderedMap.put(data, key);//这里key是map中data还没被删除时对应的值</code></pre><p>然而是我太天真了，这样做<code>orderedMap.remove(data)</code> 返回的居然是null。这就奇了怪了，我的data明明是存在map中的啊，怎么删除data会返回null呢？也就是说怎么会找不到**[1,2,7]**呢？print调试找不出错误了，只好将代码粘贴到idea中进行调试。下面是方法调用过程：</p><pre><code class="java">public V remove(Object key) &#123;    Entry&lt;K,V&gt; p = getEntry(key);    if (p == null)        return null;    V oldValue = p.value;    deleteEntry(p);    return oldValue;&#125;</code></pre><p>remove方法会先调用getEntry方法：</p><pre><code class="java">final Entry&lt;K,V&gt; getEntry(Object key) &#123;    // Offload comparator-based version for sake of performance        if (comparator != null)        return getEntryUsingComparator(key);        /*    下面的代码不用看    if (key == null)        throw new NullPointerException();    @SuppressWarnings(&quot;unchecked&quot;)    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;    Entry&lt;K,V&gt; p = root;    while (p != null) &#123;        int cmp = k.compareTo(p.key);        if (cmp &lt; 0)            p = p.left;        else if (cmp &gt; 0)            p = p.right;        else            return p;    &#125;    return null;*/&#125;</code></pre><p>这里comparator是在定义map时传入的，不为空，所以会进入getEntryUsingComparator这个方法：</p><pre><code class="java">final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;    @SuppressWarnings(&quot;unchecked&quot;)    K k = (K) key;    Comparator&lt;? super K&gt; cpr = comparator;    if (cpr != null) &#123;        Entry&lt;K,V&gt; p = root;        while (p != null) &#123;            int cmp = cpr.compare(k, p.key);            if (cmp &lt; 0)                p = p.left;            else if (cmp &gt; 0)                p = p.right;            else                return p;        &#125;    &#125;    return null;&#125;</code></pre><p>重点在if语句，由于TreeMap是基于红黑树的数据结构，<strong>查找的时候不会遍历每一个元素</strong>，而是<strong>从根节点开始查找</strong>，如果<code>compare(k, p.key)</code> 返回0，就可以将p返回；如果返回值小于0，则在树的左半边查找；如果返回值大于0，则在树的右半边查找。</p><p>看到这里我们大致知道为什么<code>orderedMap.remove(data)</code> 返回null了：一开始data在红黑树的某个位置x，修改data中的数据后，我们查找data就是在树中<strong>查找新的data应该在的位置</strong>，但是我们通过data修改map中的一个键，并不会让树重新有序（remove后再put就是想让树保持有序），也就是说data所在的位置是错误的。在map中找不到data当然通过data删除也就不行了。</p><p>如何完成正确重新排序呢？答案是先将data从map中移除（因为这个时候还没修改data中的数据，是可以从map中正确删除data的），通过data修改数据后再将data添加到map中。</p><pre><code class="java">orderedMap.remove(data);data[1] = 2;data[2] = 7;orderedMap.put(data, key);//这里key是map中data还没被删除时对应的值</code></pre><p>这样map中的数据将会是有序的（还记得排序规则吗：键的第二个元素相同时，第三个元素小的排前面，所以[1,2,7]在最后）：</p><pre><code class="java">[4, 2, 4] -&gt;  4[3, 2, 5] -&gt;  3[2, 2, 6] -&gt;  2[1, 2, 7] -&gt;  1</code></pre><p>总结：如果修改TreeMap中的键并且想保持有序，需要先移除键，在修改操作完成后再将键存入TreeMap！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在做《牛客算法必刷101》的最后一题时遇到了一个坑。原题目这里就不赘述了，原题目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>在Java中，0.4被传入System.out.print时发生了什么？</title>
    <link href="http://example.com/2023/06/09/%E5%9C%A8Java%E4%B8%AD%EF%BC%8C0.4%E8%A2%AB%E4%BC%A0%E5%85%A5System.out.print%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2023/06/09/%E5%9C%A8Java%E4%B8%AD%EF%BC%8C0.4%E8%A2%AB%E4%BC%A0%E5%85%A5System.out.print%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2023-06-09T06:55:14.609Z</published>
    <updated>2023-06-09T07:27:58.227Z</updated>
    
    <content type="html"><![CDATA[<p>在看JavaGuide复习Java基础知识的时候，看到了浮点数表示的章节。突然想知道，为什么0.4明明不能被准确表示，但是在传入System.out.println时显示到控制台的却是0.4呢？</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4    &#125;&#125;</code></pre><p>在继续阅读之前，我希望你能够具备一定的前置知识：</p><ul><li>了解浮点数是如何在计算机中表示的</li><li>了解不是所有实数都能被准确表示</li><li>0.4就是不能被准确表示的数之一</li><li>了解BigDecimal类</li></ul><p>我们可以通过BigDecimal类和System.out.println（以下简称print）来打印一个double的实际值：</p><pre><code class="java">import java.math.BigDecimal;public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4        System.out.println(new BigDecimal(d1));//打印结果：0.40000000000000002220446049250313080847263336181640625    &#125;&#125;</code></pre><p>通过上面的代码和其运行结果可以看出，当0.4被当做double字面量时，其真实值其实是0.40000000000000002220446049250313080847263336181640625。那print打印d1的时候不应该显示0.40000000000000002220446049250313080847263336181640625吗？</p><p>那为什么将d1传入print却得到0.4呢？首先我们进行一个猜想：是不是在定义变量d1时，其对应的字面量（即在写代码的时候直接写在代码中的0.4）被虚拟机记录成这样的形式(d1 –&gt; “0.4”)，然后在将double传入print时，print在虚拟机中找到d1对应的”0.4”然后打印”0.4”？这样好像是可行的，但是会有一些问题，例如：不是所有的double变量都是通过字面量直接定义的，如果这样定义d1<code> double d1 = 0.2 * 2</code> 虚拟机就不能获取”d1 –&gt;0.4”这样的信息了。难道虚拟机会记录(d1 –&gt; “0.2 * 2”)，然后在打印时打印0.2 * 2到屏幕上吗？显然不合理。那么print到底是怎么做的呢？</p><p>像0.40000000000000002220446049250313080847263336181640625这样一个值可以表示一个范围内的实数，例如从</p><pre><code class="java">import java.math.BigDecimal;public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        double d2 = 0.400000000000000000001;                System.out.println(d1);//0.4        System.out.println(d2);//0.4                System.out.println(new BigDecimal(d1));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d2));//0.40000000000000002220446049250313080847263336181640625    &#125;&#125;</code></pre><p>这个代码段可以看出0.4和0.400000000000000000001其实用的是同一个真实值来表示，即0.40000000000000002220446049250313080847263336181640625的表示范围中包含了0.4和0.400000000000000000001。<br>而double传入print时，虚拟机会调用Double.toString(double d)这个方法来将double转成一个String。而Double.toString(double d)这个方法会将参数d转换成它范围内的有效位最少的数字。例如，假设0.40000000000000002220446049250313080847263336181640625表示范围为[0.40000000000000002220446049250313080847263336181640625 - x, 0.40000000000000002220446049250313080847263336181640625 + y]，那么落在这个范围的数字通过toString转换都变成了”0.4”。而0.4000001和0.40000010000000001都落到0.400000100000000025080026944124256260693073272705078125这个数字的表示范围，通过toString转换都会变成0.4000001。</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        double d2 = 0.400000000000000000001;        double d3 = 0.4000001;        double d4 = 0.40000010000000001;                System.out.println(d1);//0.4        System.out.println(d2);//0.4        System.out.println(d3);//0.4000001        System.out.println(d4);//0.4000001                System.out.println(new BigDecimal(d1));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d2));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d3));//0.400000100000000025080026944124256260693073272705078125        System.out.println(new BigDecimal(d4));//0.400000100000000025080026944124256260693073272705078125            &#125;&#125;</code></pre><p>总结一下：</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4    &#125;&#125;</code></pre><p>这段程序可以看做经历了几个阶段：</p><ul><li>定义d1，d1的真实值为0.40000000000000002220446049250313080847263336181640625</li><li>d1被Double.toString(double)方法转换成”0.4”</li><li>“0.4”被打印到屏幕上</li></ul><p>参考:</p><ul><li><a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">https://stackoverflow.com/questions/588004/is-floating-point-math-broken</a></li><li><a href="https://stackoverflow.com/questions/22526897/how-does-java-precisely-display-a-double-while-it-cannot-be-accurately-expressed">https://stackoverflow.com/questions/22526897/how-does-java-precisely-display-a-double-while-it-cannot-be-accurately-expressed</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html">https://docs.oracle.com/javase/8/docs/api/index.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在看JavaGuide复习Java基础知识的时候，看到了浮点数表示的章节。突然想知道，为什么0.4明明不能被准确表示，但是在传入System.out.println时显示到控制台的却是0.4呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public clas</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>牛客在线编程之Java语法</title>
    <link href="http://example.com/2023/06/09/%E7%89%9B%E5%AE%A2%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E4%B9%8BJava%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/06/09/%E7%89%9B%E5%AE%A2%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E4%B9%8BJava%E8%AF%AD%E6%B3%95/</id>
    <published>2023-06-09T06:47:14.049Z</published>
    <updated>2023-06-09T07:27:37.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="牛客Java语法篇"><a href="#牛客Java语法篇" class="headerlink" title="牛客Java语法篇"></a>牛客Java语法篇</h1><p>这些题大体都没什么难度，做这些题的目的是为了熟悉Java类库。<br>绝大部分题都是直接贴上答案，但是少部分题的某些知识有所遗忘，我也会将我的学习过程写到对应题目处。</p><h2 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1. 类型转换"></a>1. 类型转换</h2><pre><code class="java">public static int typeConversion(double d)&#123;    //write your code here......    return (int) d;&#125;</code></pre><h2 id="2-简单运算"><a href="#2-简单运算" class="headerlink" title="2. 简单运算"></a>2. 简单运算</h2><pre><code class="java">int bigger = a &gt; b ? a : b;int smaller = a;if (bigger == a)    smaller = b;System.out.print(bigger + smaller);System.out.print(&quot; &quot;);System.out.print(bigger - smaller);System.out.print(&quot; &quot;);System.out.print(bigger * smaller);System.out.print(&quot; &quot;);System.out.print(bigger / smaller);System.out.print(&quot; &quot;);System.out.print(bigger % smaller);System.out.print(&quot; &quot;);</code></pre><h2 id="3-四舍五入"><a href="#3-四舍五入" class="headerlink" title="3. 四舍五入"></a>3. 四舍五入</h2><p>由于题目要求将double四舍五入为int，所以用Math.round方法。</p><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double d = scanner.nextDouble();        //write your code here......        int i = (int)Math.round(d);        System.out.println(i);    &#125;&#125;</code></pre><h2 id="4-交换变量值"><a href="#4-交换变量值" class="headerlink" title="4. 交换变量值"></a>4. 交换变量值</h2><p>为了方便注释，统一假设a、b原来的值为A,B</p><ul><li><p>方法1</p><pre><code class="java">a = a + b;// a = A + Bb = a - b;// b = A + B - B = Aa = a - b;// a = A + B - A = B</code></pre></li><li><p>方法2</p><pre><code class="java">a = a ^ b;// a = A ^ Bb = a ^ b;// b = A ^ B ^ B = Aa = a ^ b;// a = A ^ B ^ A = B</code></pre><p>理解这种做法首先要知道:</p><ul><li>A ^ A &#x3D; 0</li><li>0 ^ A &#x3D; A</li></ul></li></ul><p>上面这两种方法都是用其中一个变量保存两个变量的状态，就好像是让两个变量的值共存与一个变量(a + b、a ^ b）。然后通过某种运算从两种状态的变量提取出其中的某一个状态。</p><ul><li><p>方法3</p><pre><code class="java">i = j + (j = i) * 0;</code></pre></li></ul><p>这种方法利用了0*A &#x3D; 0,0 + A &#x3D; A，还有在Java中如果一个赋值号右边发生了赋值，右边的变量进行运算时还是使用原来的值。在其它语言中这种方法不一定适用。</p><h2 id="5-计算商场折扣"><a href="#5-计算商场折扣" class="headerlink" title="5. 计算商场折扣"></a>5. 计算商场折扣</h2><pre><code class="java">import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner console = new Scanner(System.in);        int price = console.nextInt();        int cost = price;        //write your code here......        if (price &gt;= 5000) &#123;            cost = (int) (price * 0.6);        &#125; else if (price &gt;= 2000) &#123;            cost = (int) (price * 0.7);        &#125; else if (price &gt;= 500) &#123;            cost = (int) (price * 0.8);        &#125; else if (price &gt;= 100) &#123;            cost = (int) (price * 0.9);        &#125;        System.out.println(cost);    &#125;&#125;</code></pre><h2 id="6-判断体重指数"><a href="#6-判断体重指数" class="headerlink" title="6. 判断体重指数"></a>6. 判断体重指数</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double height = scanner.nextDouble();        double weight = scanner.nextDouble();        //write your code here......        double index = weight / (height * height);        if (index &lt; 18.5) &#123;            System.out.print(&quot;偏瘦&quot;);        &#125; else if (index &lt; 20.9) &#123;            System.out.print(&quot;苗条&quot;);        &#125; else if (index &lt; 24.9) &#123;            System.out.print(&quot;适中&quot;);        &#125; else &#123;            System.out.print(&quot;偏胖&quot;);        &#125;    &#125;&#125;</code></pre><h2 id="7-判断学生成绩等级"><a href="#7-判断学生成绩等级" class="headerlink" title="7. 判断学生成绩等级"></a>7. 判断学生成绩等级</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String grade =scanner.next();        //write your code here......        if (grade == null) &#123;            System.out.print(&quot;未知等级&quot;);            return;        &#125;        if (grade.equals(&quot;A&quot;)) &#123;            System.out.print(&quot;优秀&quot;);        &#125; else if (grade.equals(&quot;B&quot;)) &#123;            System.out.print(&quot;良好&quot;);        &#125; else if (grade.equals(&quot;C&quot;)) &#123;            System.out.print(&quot;及格&quot;);        &#125; else if (grade.equals(&quot;D&quot;)) &#123;            System.out.print(&quot;不及格&quot;);        &#125; else &#123;            System.out.print(&quot;未知等级&quot;);        &#125;    &#125;&#125;</code></pre><h2 id="8-邮箱验证"><a href="#8-邮箱验证" class="headerlink" title="8. 邮箱验证"></a>8. 邮箱验证</h2><pre><code class="java">import java.util.Scanner;import java.util.regex.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.next();        String emailMatcher=&quot;[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z0-9]+&quot;;        //write your code here......        boolean isEmail = Pattern.matches(emailMatcher, str);        if (isEmail) &#123;            System.out.print(&quot;邮箱格式合法&quot;);        &#125; else &#123;            System.out.print(&quot;邮箱格式不合法&quot;);        &#125;    &#125;&#125;</code></pre><p>Java正则表达式</p><p><a href="https://www.runoob.com/java/java-regular-expressions.html">https://www.runoob.com/java/java-regular-expressions.html</a></p><ul><li><p>简介</p><ul><li><p>正则表达式定义了字符串的模式。</p></li><li><p>正则表达式可以用来搜索、编辑或处理文本。</p></li><li><p>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。</p></li></ul></li><li><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p><strong>Pattern 类：</strong></p><p>pattern 对象是一个正则表达式的<strong>编译表示</strong>。Pattern 类<strong>没有公共构造方法</strong>。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p><strong>Matcher 类：</strong></p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p></li><li><p><strong>PatternSyntaxException：</strong></p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><p>实例</p><pre><code class="java">import java.util.regex.*; class RegexExample1&#123;   public static void main(String[] args)&#123;      String content = &quot;I am noob &quot; +        &quot;from runoob.com.&quot;;       String pattern = &quot;.*runoob.*&quot;;       boolean isMatch = Pattern.matches(pattern, content);      System.out.println(&quot;字符串中是否包含了 &#39;runoob&#39; 子字符串? &quot; + isMatch);//true   &#125;&#125;</code></pre></li></ul><h2 id="9-数列求和"><a href="#9-数列求和" class="headerlink" title="9. 数列求和"></a>9. 数列求和</h2><pre><code class="java">long num = 0;long sum = 0L;for (int i = 1; i &lt;= 10; i++) &#123;    num = num * 10L + 9L;    sum += num;&#125;System.out.print(sum);</code></pre><h2 id="10-统计输入正数个数"><a href="#10-统计输入正数个数" class="headerlink" title="10. 统计输入正数个数"></a>10. 统计输入正数个数</h2><pre><code class="java">int i = -1;int num;do &#123;    i++;    num = scanner.nextInt();&#125; while(num &gt; 0);System.out.print(i);scanner.close();</code></pre><h2 id="11-求最小公倍数"><a href="#11-求最小公倍数" class="headerlink" title="11. 求最小公倍数"></a>11. 求最小公倍数</h2><pre><code class="java">public static int getCM(int m, int n)&#123;    //write your code here......    int b = m &gt; n ? m : n;//大的那一个    int s = (b == m) ? n : m;//小的那一个    int result = b;    while (result%s != 0) &#123;        result += b;    &#125;    return result;&#125;</code></pre><h2 id="12-小球走过的路程计算"><a href="#12-小球走过的路程计算" class="headerlink" title="12. 小球走过的路程计算"></a>12. 小球走过的路程计算</h2><pre><code class="java">double total = 0;do &#123;    total += h;    h = h / 2.0f;    total += h;&#125; while (--n &gt; 0);total = total - h;//输出格式为：System.out.println(String.format(&quot;%.3f&quot;, h)+&quot; &quot;+String.format(&quot;%.3f&quot;, sum));System.out.println(String.format(&quot;%.3f&quot;, h)+&quot; &quot;+String.format(&quot;%.3f&quot;, total));</code></pre><h2 id="13-求平均数"><a href="#13-求平均数" class="headerlink" title="13. 求平均数"></a>13. 求平均数</h2><pre><code class="java">Long total = 0L;int num = 0;int nextInt = 0;while (scan.hasNextInt() &amp;&amp; (nextInt = scan.nextInt()) &gt;= 0) &#123;    total += nextInt;    num++;&#125;double avg = (double)total / num;System.out.println(String.format(&quot;%.2f&quot;, avg));</code></pre><h2 id="14-判断质数"><a href="#14-判断质数" class="headerlink" title="14. 判断质数"></a>14. 判断质数</h2><pre><code class="java">public Boolean isPrimeNumber(int number) &#123;    //write your code here......    int i = number / 2;    for (int j = i; j &gt; 1; j--) &#123;        if (number % j == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><h2 id="15-计算整数位数"><a href="#15-计算整数位数" class="headerlink" title="15. 计算整数位数"></a>15. 计算整数位数</h2><pre><code class="java">if (num &lt;= 0) &#123;    System.out.print(num);&#125; else &#123;    int n = 0;    while (num &gt; 0) &#123;        n++;        num /= 10;    &#125;    System.out.print(n);&#125;</code></pre><h2 id="16-数组遍历"><a href="#16-数组遍历" class="headerlink" title="16. 数组遍历"></a>16. 数组遍历</h2><pre><code class="java">max = Integer.MIN_VALUE;min = Integer.MAX_VALUE;for (int n: ary) &#123;    max = n &gt; max ? n : max;    min = n &lt; min ? n : min;&#125;</code></pre><h2 id="17-数组倒转"><a href="#17-数组倒转" class="headerlink" title="17. 数组倒转"></a>17. 数组倒转</h2><pre><code class="java">int temp;for (int i = 0; i &lt; arr.length / 2; i++) &#123;    temp = arr[i];    arr[i] = arr[arr.length - i - 1];    arr[arr.length - i - 1] = temp;&#125;</code></pre><h2 id="18-二维数组求和"><a href="#18-二维数组求和" class="headerlink" title="18. 二维数组求和"></a>18. 二维数组求和</h2><pre><code class="java">for (int i = 0; i &lt; arr.length; i++) &#123;    int[] rowArr = arr[i];    for (int j = 0; j &lt; rowArr.length; j++) &#123;        sum += rowArr[j];    &#125;&#125;</code></pre><h2 id="19-修改Data类的定义"><a href="#19-修改Data类的定义" class="headerlink" title="19. 修改Data类的定义"></a>19. 修改Data类的定义</h2><pre><code class="java">class Data &#123;    private int x;    private int y;        public Data(int x, int y) &#123;        this.x = x;        this.y = y;    &#125;    public int getX() &#123;        return x;    &#125;    public int getY() &#123;        return y;    &#125;&#125;</code></pre><h2 id="20-验证年龄"><a href="#20-验证年龄" class="headerlink" title="20. 验证年龄"></a>20. 验证年龄</h2><pre><code class="java">class Person &#123;    private int age;    //write your code here......    public void setAge(int age) &#123;        if (age &lt; 0) &#123;            this.age = 0;         &#125; else if (age &gt; 200) &#123;            this.age = 200;        &#125; else &#123;            this.age = age;        &#125;            &#125;    public int getAge() &#123;        return age;    &#125;&#125;</code></pre><h2 id="21-补全构造方法"><a href="#21-补全构造方法" class="headerlink" title="21. 补全构造方法"></a>21. 补全构造方法</h2><pre><code class="java">super(x, y);this.z = z;</code></pre><h2 id="22-重写计算逻辑"><a href="#22-重写计算逻辑" class="headerlink" title="22. 重写计算逻辑"></a>22. 重写计算逻辑</h2><p>这里遇到了一点小插曲。因为题目中没有说要写子类构造方法，我也就没注意，结果编译时报错了。</p><pre><code>Main.java:10: error: constructor Sub in class Sub cannot be applied to given types;Sub sub = new Sub(x, y);required: no argumentsfound: int,int</code></pre><p>大致意思就是我没有提供Sub(int,int)这样的构造函数。我看了一下，基类有构造函数Base(int x, int y)，我突然回忆不起默认构造函数在父类有构造函数时是怎样的情况了。于是到网上搜了一下，发现很多讲默认构造函数的文章都是一笔带过，没办法直接看Java Se 8 Specification吧。规范中给出了这样的示例：</p><p>下面的声明：</p><pre><code class="java">public class Point &#123;    int x, y;&#125;</code></pre><p>与这个声明相同：</p><pre><code class="java">public class Point &#123;    int x, y;    public Point() &#123; super(); &#125;&#125;</code></pre><p>所以父类如果没有无参构造函数，子类就不能使用默认构造函数了。（看到这个示例的时候又觉得自己的记忆中就是这样的情况，但是有时候脑子就是这样，看到答案时会觉得简单）</p><p>补齐构造函数：</p><pre><code class="java">class Sub extends Base &#123;    public Sub(int x, int y) &#123;        super(x, y);    &#125;    //write your code here......    @Override    public void calculate() &#123;        System.out.println(getY() == 0 ? &quot;Error&quot; : getX() / getY());    &#125;&#125;</code></pre><h2 id="23-定义打印方法"><a href="#23-定义打印方法" class="headerlink" title="23. 定义打印方法"></a>23. 定义打印方法</h2><pre><code class="java">private static void print(Object obj) &#123;    System.out.print(obj.toString());&#125;</code></pre><h2 id="24-类型判断"><a href="#24-类型判断" class="headerlink" title="24. 类型判断"></a>24. 类型判断</h2><pre><code class="java">public static String getClassName(Base obj) &#123;    //write your code here......    if (obj instanceof Sub2) &#123;        return &quot;Sub2&quot;;    &#125; else if (obj instanceof Sub1) &#123;        return &quot;Sub1&quot;;    &#125; else &#123;        return &quot;Base&quot;;    &#125;&#125;</code></pre><h2 id="25-实现抽象方法"><a href="#25-实现抽象方法" class="headerlink" title="25. 实现抽象方法"></a>25. 实现抽象方法</h2><pre><code class="java">class Sub extends Base &#123;    //write your code here......    @Override    public int sum() &#123;        return getX() + getY();    &#125;    @Override     public int avg() &#123;        return sum() / 2;    &#125;&#125;</code></pre><h2 id="26-实现接口"><a href="#26-实现接口" class="headerlink" title="26. 实现接口"></a>26. 实现接口</h2><pre><code class="java">class ComparatorImpl implements Comparator &#123;    @Override    public int max(int x, int y) &#123;        return x &gt; y ? x : y;    &#125;&#125;</code></pre><p>这里我以为接口方法在实现时不能加@Override，结果是可以的。看来@Override不止可以用于重写父类的方法。</p><p>SE8官方文档中这样写到：</p><p><strong>If a method declaration is annotated with the annotation</strong> <code>@Override</code><strong>, but the method does not override or implement a method declared in a supertype, or is not override-equivalent to a</strong> <code>public</code> <strong>method of</strong> <code>Object</code><strong>, a compile-time error occurs.</strong></p><p>翻译：如果一个方法声明用@Override进行注解，但是方法没有重写或者<strong>实现</strong>声明在超类型中方法，或者对Object的公共方法来说不是override-equivalent的，那么就会产生一个编译时错误。</p><p>看到这里已经可以解决上面的问题了：@Override可以用于实现接口方法声明的方法。</p><p>但是新的疑问又产生了：So what is override-equivalent?</p><p>首先给出我的答案来源：<a href="https://stackoverflow.com/questions/16207386/what-is-override-equivalence-and-how-is-it-related-to-override">https://stackoverflow.com/questions/16207386/what-is-override-equivalence-and-how-is-it-related-to-override</a></p><p>但是我没看楼主的答案，而是根据楼主的提示——官方文档中有解释——找到了答案。</p><p>The signature of a method <code>m1</code> is a <em>subsignature</em> of the signature of a method <code>m2</code> if either:</p><ul><li><code>m2</code> has the same signature as <code>m1</code>, or</li><li>the signature of <code>m1</code> is the same as the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6">§4.6</a>) of the signature of <code>m2</code>.</li></ul><p>Two method signatures <code>m1</code> and <code>m2</code> are <em>override-equivalent</em> iff either <code>m1</code> is a subsignature of <code>m2</code> or <code>m2</code> is a subsignature of <code>m1</code>.</p><p>大致意思是说：函数签名是override-equivalent的条件是m1是m2的子签名或者m2是m1的子签名。而如果方法m2的签名与方法m1的签名相同或者m1的签名与m2的签名的erasure相同，则可以说m1的子签名是m2的签名的子签名。</p><p>那什么又是erasure捏？（苦笑）</p><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6">https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6</a> 内容实在是有点多，如果有时间我会斗胆翻译一下，感兴趣的可以去看看。</p><h2 id="27-重写父类方法"><a href="#27-重写父类方法" class="headerlink" title="27. 重写父类方法"></a>27. 重写父类方法</h2><pre><code class="java">class Sub extends Base &#123;    public Sub(int x, int y) &#123;        super(x, y);    &#125;    //write your code here......    @Override    public int getX() &#123;        return super.getX() * 10;    &#125;&#125;</code></pre><h2 id="28-创建单例对象"><a href="#28-创建单例对象" class="headerlink" title="28. 创建单例对象"></a>28. 创建单例对象</h2><pre><code class="java">public static Singleton getInstance() &#123;    if (instance == null) &#123;        instance = new Singleton();    &#125;    return instance;&#125;</code></pre><h2 id="29-动态字符串"><a href="#29-动态字符串" class="headerlink" title="29. 动态字符串"></a>29. 动态字符串</h2><pre><code class="java">int len = str.length();int remainder = len % 3;int commas = len / 3 - 1;if (remainder != 0) &#123;    commas++;&#125;StringBuilder newStr = new StringBuilder(commas + len);for (int i  = 0; i &lt; len; i++) &#123;    newStr.append(str.charAt(i));    if ((i+1) % 3 == remainder &amp;&amp; i != len - 1) &#123;        newStr.append(&quot;,&quot;);    &#125;&#125;System.out.print(newStr);</code></pre><h2 id="30-统计字符串中字母出现次数"><a href="#30-统计字符串中字母出现次数" class="headerlink" title="30. 统计字符串中字母出现次数"></a>30. 统计字符串中字母出现次数</h2><pre><code class="java">public static int check(String str, String word) &#123;    //write your code here......    int times = 0;    int from = -1;    while (true) &#123;        from = str.indexOf(word, from + 1);        if (from == -1) &#123;            break;        &#125;        times++;    &#125;    return times;&#125;</code></pre><h2 id="31-十进制数转二进制数"><a href="#31-十进制数转二进制数" class="headerlink" title="31. 十进制数转二进制数"></a>31. 十进制数转二进制数</h2><pre><code class="java">//write your code here......StringBuilder strNum = new StringBuilder();while (num &gt; 0) &#123;    strNum.insert(0, num % 2);    num /= 2;&#125;//这里题目的输入描述其实说了输入的是正整数，但是测试用例里有0System.out.println(strNum.length() &gt; 0 ? strNum : 0);</code></pre><h2 id="33-掷骰子"><a href="#33-掷骰子" class="headerlink" title="33. 掷骰子"></a>33. 掷骰子</h2><pre><code class="java">System.out.print(random.nextInt(6) + 1);</code></pre><h2 id="34-求绝对值，平方根，对数，正弦值"><a href="#34-求绝对值，平方根，对数，正弦值" class="headerlink" title="34. 求绝对值，平方根，对数，正弦值"></a>34. 求绝对值，平方根，对数，正弦值</h2><pre><code class="java">System.out.println(Math.abs(num));System.out.println(Math.sqrt(num));System.out.println(Math.log(num));System.out.println(Math.sin(num));</code></pre><h2 id="35-输出某一年的各个月份的天数"><a href="#35-输出某一年的各个月份的天数" class="headerlink" title="35. 输出某一年的各个月份的天数"></a>35. 输出某一年的各个月份的天数</h2><p>没怎么用过Calendar这个类，感觉自己写得太麻烦了。</p><pre><code class="java">import java.util.Calendar;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner console = new Scanner(System.in);        int year = console.nextInt();        //write your code here......        Calendar cal = Calendar.getInstance();        cal.set(year, 0, 1);//Calendar类月份从0开始计！即0表示1月份。        int month = 1;//用于记录当前的月份        int countDay = 0;//用于记录一个月的天数        while (month &lt;= 12) &#123;            cal.add(Calendar.DAY_OF_MONTH, 1);            countDay++;            while (cal.get(Calendar.DAY_OF_MONTH) != 1) &#123;                cal.add(Calendar.DAY_OF_MONTH, 1);                countDay++;            &#125;                                    System.out.println(year + &quot;年&quot; + month + &quot;月:&quot; + countDay + &quot;天&quot;);            countDay = 0;            month++;        &#125;    &#125;&#125;</code></pre><h2 id="36-日期换算"><a href="#36-日期换算" class="headerlink" title="36. 日期换算"></a>36. 日期换算</h2><pre><code class="java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);Scanner in = new Scanner(System.in);String str1 = in.nextLine();//write your code here......String[] dateTimeStr = str1.split(&quot; &quot;);if (dateTimeStr.length &lt; 6) &#123;    System.out.print(&quot;您输入的数据不合理&quot;);    return;&#125;            int year = Integer.valueOf(dateTimeStr[0]);int month = Integer.valueOf(dateTimeStr[1]);int day = Integer.valueOf(dateTimeStr[2]);int hour = Integer.valueOf(dateTimeStr[3]);int minute = Integer.valueOf(dateTimeStr[4]);int second = Integer.valueOf(dateTimeStr[5]);     LocalDateTime dateTime = LocalDateTime.of(year, 1, 1, 0, 0, 0);dateTime = dateTime.plusMonths(month-1);dateTime = dateTime.plusDays(day-1);dateTime = dateTime.plusHours(hour);dateTime = dateTime.plusMinutes(minute);dateTime = dateTime.plusSeconds(second);System.out.println(&quot;北京时间为：&quot; + dateTime.format(dtf));dateTime = dateTime.minusHours(12);System.out.println(&quot;纽约时间为：&quot; + dateTime.format(dtf));</code></pre><h2 id="37-判断学生成绩"><a href="#37-判断学生成绩" class="headerlink" title="37. 判断学生成绩"></a>37. 判断学生成绩</h2><pre><code class="java">import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int score = scanner.nextInt();        //write your code here......        try &#123;            if (!(score &gt;= 0 &amp;&amp; score &lt;= 100)) &#123;                throw new ScoreException(&quot;分数不合法&quot;);            &#125;            System.out.println(score);        &#125; catch (ScoreException ex)&#123;            System.out.println(ex.getMessage());        &#125;    &#125;&#125;class ScoreException extends Exception &#123;    //write your code here......    public ScoreException(String message) &#123;        super(message);    &#125;&#125;</code></pre><h2 id="38-字符串去重"><a href="#38-字符串去重" class="headerlink" title="38. 字符串去重"></a>38. 字符串去重</h2><pre><code class="java">import java.util.HashSet;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.nextLine();        scanner.close();        HashSet&lt;Character&gt; hs = new HashSet&lt;&gt;();        //write your code here......        for (int i = 0; i &lt; str.length(); i++) &#123;            hs.add(str.charAt(i));        &#125;        for (char c:hs) &#123;            System.out.print(c);        &#125;    &#125;&#125;</code></pre><h2 id="39-集合遍历"><a href="#39-集合遍历" class="headerlink" title="39. 集合遍历"></a>39. 集合遍历</h2><pre><code class="java">import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int num1 = scanner.nextInt();        int num2 = scanner.nextInt();        int num3 = scanner.nextInt();        int num4 = scanner.nextInt();        int num5 = scanner.nextInt();        scanner.close();        list.add(num1);        list.add(num2);        list.add(num3);        list.add(num4);        list.add(num5);        System.out.print(&quot;普通for循环:&quot;);        //write your code here......        for (int i = 0; i &lt; list.size(); i++) &#123;            System.out.print(list.get(i) + &quot; &quot;);        &#125;        System.out.println();        System.out.print(&quot;增强for循环:&quot;);        //write your code here......        for (int n: list) &#123;            System.out.print(n + &quot; &quot;);        &#125;        System.out.println();        System.out.print(&quot;迭代器遍历:&quot;);        //write your code here......        Iterator iter =  list.listIterator();        while (iter.hasNext()) &#123;            System.out.print(iter.next() + &quot; &quot;);        &#125;        System.out.println();    &#125;&#125;</code></pre><h2 id="40-排队系统"><a href="#40-排队系统" class="headerlink" title="40. 排队系统"></a>40. 排队系统</h2><pre><code class="java">//write your code here......deque.addFirst(vipGuest);</code></pre><h2 id="41-Head-and-Tail-of-the-Queue"><a href="#41-Head-and-Tail-of-the-Queue" class="headerlink" title="41. Head and Tail of the Queue"></a>41. Head and Tail of the Queue</h2><pre><code class="java">// write your code here......boolean turnToHead = true;while (!deque.isEmpty()) &#123;    if (turnToHead) &#123;        System.out.println(deque.removeFirst());    &#125; else &#123;        System.out.println(deque.removeLast());    &#125;    turnToHead = !turnToHead;&#125;</code></pre><h2 id="42-统计一句话中重复单词的个数"><a href="#42-统计一句话中重复单词的个数" class="headerlink" title="42. 统计一句话中重复单词的个数"></a>42. 统计一句话中重复单词的个数</h2><pre><code class="java">//write your code here......for (int i = 0; i &lt; line.length(); i++) &#123;    Character c = line.charAt(i);    if (Character.isAlphabetic(c)) &#123;        Integer originNum = map.get(c);        if (originNum == null) &#123;            map.put(c, 1);        &#125; else &#123;            map.put(c, originNum + 1);        &#125;    &#125;&#125;</code></pre><h2 id="43-map简单应用"><a href="#43-map简单应用" class="headerlink" title="43. map简单应用"></a>43. map简单应用</h2><pre><code class="java">//write your code here......Set&lt;Integer&gt; keySet = map.keySet();Iterator&lt;Integer&gt; iter = keySet.iterator();while (iter.hasNext()) &#123;    Integer key = iter.next();    System.out.println(key + &quot;:&quot; + map.get(key));&#125;System.out.println();map.put(5, name);map.remove(4);map.put(3, &quot;Tommy&quot;);iter = keySet.iterator();while (iter.hasNext()) &#123;    Integer key = iter.next();    System.out.println(key + &quot;:&quot; + map.get(key));&#125;</code></pre><h2 id="44-集合排序"><a href="#44-集合排序" class="headerlink" title="44. 集合排序"></a>44. 集合排序</h2><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        //其余代码省略        //write your code here......        Collections.sort(customers);        System.out.println(customers);    &#125;&#125;class Customer implements Comparable&lt;Customer&gt;&#123;    //其余代码省略    //write your code here......    @Override    public int compareTo(Customer other) &#123;        return other.consumption - consumption;    &#125;&#125;</code></pre><h2 id="45-判断各类型字符个数"><a href="#45-判断各类型字符个数" class="headerlink" title="45. 判断各类型字符个数"></a>45. 判断各类型字符个数</h2><pre><code class="java">//write your code here......for (int i = 0; i &lt; str.length(); i++) &#123;    if (str.charAt(i) == &#39; &#39;) &#123;        space++;    &#125; else if (Character.isAlphabetic(str.charAt(i))) &#123;        words++;    &#125; else if (Character.isDigit(str.charAt(i))) &#123;        numbers++;    &#125; else &#123;        other++;    &#125;&#125;</code></pre><h2 id="46-编写个人所得税计算程序"><a href="#46-编写个人所得税计算程序" class="headerlink" title="46. 编写个人所得税计算程序"></a>46. 编写个人所得税计算程序</h2><pre><code class="java">import java.util.*;public class Main &#123;    //税率    private static final double[] taxRates = &#123;0.03, 0.1, 0.2, 0.25, 0.3, 0.35, 0.45&#125;;    //速算扣除数    private static final double[] shouldMinus = &#123;0.0, 105.0, 555.0, 1005.0, 2755.0, 5505.0, 13505.0&#125;;    public static void main(String[] args) &#123;        List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();        //write your code here......        //应纳税额 =（工资薪金所得－扣除数）×适用税率－速算扣除数        //扣除数为3500元        //全月应纳税所得额=工资薪金所得－扣除数。        employees.add(new Employee(&quot;小明&quot;, 2500));        employees.add(new Employee(&quot;小军&quot;, 8000));        employees.add(new Employee(&quot;小红&quot;, 100000));        for (Employee emp : employees) &#123;            System.out.println(emp.getName() + &quot;应该缴纳的个人所得税是：&quot; + getTax(emp));        &#125;    &#125;    /**     * 自定义方法，输入一个雇员，返回雇员所得税。     */    public static double getTax(Employee emp) &#123;        double salary = emp.getSalary();        if (Double.compare(salary, 3500) &lt; 0) &#123;            return 0.0;        &#125;                double monthIncome = salary - 3500.0;//全月应纳税所得额        if (Double.compare(monthIncome, 1500.0) &lt;= 0) &#123;            return monthIncome * taxRates[0] - shouldMinus[0];        &#125; else if (Double.compare(monthIncome, 4500.0) &lt;= 0) &#123;            return monthIncome * taxRates[1] - shouldMinus[1];        &#125; else if (Double.compare(monthIncome, 9000.0) &lt;= 0) &#123;            return monthIncome * taxRates[2] - shouldMinus[2];        &#125; else if (Double.compare(monthIncome, 35000.0) &lt;= 0) &#123;            return monthIncome * taxRates[3] - shouldMinus[3];        &#125; else if (Double.compare(monthIncome, 55000.0) &lt;= 0) &#123;            return monthIncome * taxRates[4] - shouldMinus[4];        &#125; else if (Double.compare(monthIncome, 80000.0) &lt;= 0) &#123;            return monthIncome * taxRates[5] - shouldMinus[5];        &#125; else&#123;            return monthIncome * taxRates[6] - shouldMinus[6];        &#125;    &#125;&#125;class Employee&#123;    private String name;    private double salary;    public Employee(String name, double salary) &#123;        this.name = name;        this.salary = salary;    &#125;    public String getName() &#123;        return name;    &#125;    public double getSalary() &#123;        return salary;    &#125;&#125;</code></pre><h2 id="47-记录点赞用户"><a href="#47-记录点赞用户" class="headerlink" title="47. 记录点赞用户"></a>47. 记录点赞用户</h2><pre><code class="java">class LikeRecorderImpl implements LikeRecorder &#123;    // write your code here......    private static final HashSet&lt;String&gt; likeNames = new HashSet&lt;&gt;();    @Override    public void like(String username) &#123;        if (likeNames.contains(username)) &#123;            likeNames.remove(username);            return;        &#125;        likeNames.add(username);    &#125;    @Override    public String[] getLikeUsers() &#123;        String[] result = new String[likeNames.size()];        return likeNames.toArray(result);    &#125;&#125;</code></pre><h2 id="48-回文数判断"><a href="#48-回文数判断" class="headerlink" title="48. 回文数判断"></a>48. 回文数判断</h2><pre><code class="java">public Boolean palindromeNumber(int number) &#123;    //write your code here......    String numberStr = &quot;&quot; + number;    for (int i = 0; i &lt; numberStr.length() / 2; i++) &#123;        if (numberStr.charAt(i) != numberStr.charAt(numberStr.length() - i - 1)) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><h2 id="49-判断素数个数"><a href="#49-判断素数个数" class="headerlink" title="49. 判断素数个数"></a>49. 判断素数个数</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int start = scanner.nextInt();        int end = scanner.nextInt();        method(start,end);    &#125;    public static void method(int start, int end) &#123;        int count=0;        //write your code here......        start = start &gt; end ? end + 0 * (end = start) : start;//如果start &gt; end交换start和end的值        for (int i = start; i &lt;= end; i++) &#123;            if (isPrimeGreaterThan2(i)) &#123;                count++;            &#125;        &#125;        System.out.println(start+&quot;到&quot;+end+&quot;之间有&quot;+count+&quot;个大于2的素数&quot;);    &#125;    public static boolean isPrimeGreaterThan2(int n) &#123;        if (n &lt;= 2)            return false;        for (int i = 2; i &lt;= n / 2; i++) &#123;            if (n % i == 0)                return false;        &#125;        return true;    &#125;&#125;</code></pre><h2 id="50-根据周长求面积"><a href="#50-根据周长求面积" class="headerlink" title="50. 根据周长求面积"></a>50. 根据周长求面积</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextDouble()) &#123;            double s = scanner.nextDouble();            // Circle和Square是需要你定义的类            System.out.println(String.format(&quot;%.3f&quot;,new Circle(s).getArea()));            System.out.println(String.format(&quot;%.3f&quot;, new Square(s).getArea()));        &#125;    &#125;&#125;class Shape &#123;    private double s; // 周长    public Shape(double s) &#123;        this.s = s;    &#125;    public double getS() &#123;        return s;    &#125;&#125;interface Area &#123;    double getArea(); // 面积&#125;// 圆形class Circle extends Shape implements Area &#123;    //write your code here......    public Circle(double s) &#123;        super(s);    &#125;    @Override    public double getArea() &#123;        double radius = getS() / (2 * Math.PI);        return radius * radius * Math.PI;    &#125;&#125;// 方形class Square extends Shape implements Area &#123;    //write your code here......    public Square(double s) &#123;        super(s);    &#125;    @Override    public double getArea() &#123;        double radius = getS() / 4;        return radius * radius;    &#125;&#125;</code></pre><h2 id="51-冒泡排序"><a href="#51-冒泡排序" class="headerlink" title="51. 冒泡排序"></a>51. 冒泡排序</h2><pre><code class="java">//write your code here......int temp;for (int i = arr.length - 1; i &gt;= 0; i--) &#123;    for (int j  = 0; j &lt; i; j++) &#123;        if (arr[j] &gt; arr[j+1]) &#123;            temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;牛客Java语法篇&quot;&gt;&lt;a href=&quot;#牛客Java语法篇&quot; class=&quot;headerlink&quot; title=&quot;牛客Java语法篇&quot;&gt;&lt;/a&gt;牛客Java语法篇&lt;/h1&gt;&lt;p&gt;这些题大体都没什么难度，做这些题的目的是为了熟悉Java类库。&lt;br&gt;绝大部分题都是</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
</feed>
