<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>CMU15-445学习记录</title><meta name="description" content="热爱，专注"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Project #0 - C++ Primer简介项目0的目的是让参加这门课的同学确定自己有足够的C++功底来完成这门课的所有项目，如果有同学没有在规定时间内完成项目0，会被从选课名单中移除。
前置知识C++显式使用SMF的默认版本class TrieNode &amp;#123;
 public:
  TrieNode() = default;
  //省略其它代码
&amp;#125;;

在SMF声明时，参数列表括号后面添加= default就可以让编译器提供SMF的默认版本。
explicithttps://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/explicit
class TrieNode &amp;#123;
 public:
 .."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="fertfest的个人记录" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">fertfest's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">CMU15-445学习记录</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-0-C-Primer"><span class="toc-text">Project #0 - C++ Primer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C"><span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E4%BD%BF%E7%94%A8SMF%E7%9A%84%E9%BB%98%E8%AE%A4%E7%89%88%E6%9C%AC"><span class="toc-text">显式使用SMF的默认版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#explicit"><span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#virtual"><span class="toc-text">virtual</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#auto-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE"><span class="toc-text">auto 和 类型后置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#override"><span class="toc-text">override</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string-view"><span class="toc-text">string_view</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie"><span class="toc-text">Trie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GoogleTest"><span class="toc-text">GoogleTest</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Assertions"><span class="toc-text">Assertions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-text">简单测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">实现思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Task-1-Copy-On-Write-Trie"><span class="toc-text">Task #1 - Copy-On-Write Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-key"><span class="toc-text">Get(key)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Put-key-value"><span class="toc-text">Put(key, value)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Remove-key"><span class="toc-text">Remove(key)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task-2-Concurrent-Key-Value-Store"><span class="toc-text">Task #2 - Concurrent Key-Value Store</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E5%9B%BD%E5%A4%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B"><i class="tag post-item-tag">国外计算机课程</i></a><a href="/tags/Cpp"><i class="tag post-item-tag">Cpp</i></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93"><i class="tag post-item-tag">数据库</i></a><a href="/tags/CMU"><i class="tag post-item-tag">CMU</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">CMU15-445学习记录</h1><time class="has-text-grey" datetime="2023-06-22T10:19:59.421Z">2023-06-22</time><article class="mt-2 post-content"><h2 id="Project-0-C-Primer"><a href="#Project-0-C-Primer" class="headerlink" title="Project #0 - C++ Primer"></a>Project #0 - C++ Primer</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>项目0的目的是让参加这门课的同学确定自己有足够的C++功底来完成这门课的所有项目，如果有同学没有在规定时间内完成项目0，会被从选课名单中移除。</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="显式使用SMF的默认版本"><a href="#显式使用SMF的默认版本" class="headerlink" title="显式使用SMF的默认版本"></a>显式使用SMF的默认版本</h5><pre><code class="c++">class TrieNode &#123;
 public:
  TrieNode() = default;
  //省略其它代码
&#125;;
</code></pre>
<p>在SMF声明时，参数列表括号后面添加<code>= default</code>就可以让编译器提供SMF的默认版本。</p>
<h5 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h5><p><a target="_blank" rel="noopener" href="https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/explicit">https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/explicit</a></p>
<pre><code class="c++">class TrieNode &#123;
 public:
  explicit TrieNode(std::map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt; children) : children_(std::move(children)) &#123;&#125;
&#125;;
</code></pre>
<p>禁止使用<code>TrieNode t1 = some_map; </code>这样的初始化方式。</p>
<h5 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h5><p><a target="_blank" rel="noopener" href="https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/virtual">https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/virtual</a></p>
<pre><code class="c++">class TrieNode &#123;
 public:
  virtual ~TrieNode() = default;
&#125;;
</code></pre>
<p>这里同时使用了virtual和default关键字。这样当TreeNode被继承且子类重写析构函数后，删除TreeNode(父类)指针或引用时，将会调用指针或引用对应的对象的析构函数。</p>
<h5 id="auto-和-类型后置"><a href="#auto-和-类型后置" class="headerlink" title="auto 和 类型后置"></a>auto 和 类型后置</h5><p><a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#trailing_return">https://google.github.io/styleguide/cppguide.html#trailing_return</a></p>
<pre><code class="c++">class TrieNode &#123;
 public:
  virtual auto Clone() const -&gt; std::unique_ptr&lt;TrieNode&gt; &#123; 
      return std::make_unique&lt;TrieNode&gt;(children_); 
  &#125;
&#125;;
</code></pre>
<p>这里使用了类型后置特性但是后置类型却是一个确定的类型，并没有用到类型推导，我猜测这样写是为了统一函数原型的风格。</p>
<h5 id="override"><a href="#override" class="headerlink" title="override"></a>override</h5><p><a target="_blank" rel="noopener" href="https://github.com/Light-City/CPlusPlusThings/blob/master/cpp2.0/cpp11/override.cpp">https://github.com/Light-City/CPlusPlusThings/blob/master/cpp2.0/cpp11/override.cpp</a></p>
<pre><code class="c++">template &lt;class T&gt;
class TrieNodeWithValue : public TrieNode &#123;
 public:
  auto Clone() const -&gt; std::unique_ptr&lt;TrieNode&gt; override &#123;
    return std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(children_, value_);
  &#125;
&#125;;
</code></pre>
<p>override关键字类似于Java的Override注解，如果加了override的函数没有重写父类的虚函数，在编译时编译器会报错！</p>
<h5 id="string-view"><a href="#string-view" class="headerlink" title="string_view"></a>string_view</h5><p><a target="_blank" rel="noopener" href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/">https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/</a></p>
<p>当你需要只读的string时，比起string来说string_view更好！</p>
<h4 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h4><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trie#:~:text=A%20prefix%20trie%20is%20an,of%20words%20with%20common%20prefixes.">Trie</a></p>
<h4 id="GoogleTest"><a href="#GoogleTest" class="headerlink" title="GoogleTest"></a>GoogleTest</h4><p>GoogleTest是Google的C++测试和mocking框架。</p>
<p><a target="_blank" rel="noopener" href="https://google.github.io/googletest/">https://google.github.io/googletest/</a></p>
<h5 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h5><p><a target="_blank" rel="noopener" href="https://google.github.io/googletest/reference/assertions.html">https://google.github.io/googletest/reference/assertions.html</a></p>
<ul>
<li><p>GTest中的断言都是成对的，分为ASSERT_版和EXPECT_版，ASSERT_版在测试失败时生成<strong>致命错误</strong>(fatal failures)，而EXPECT_版在测试失败时生成<strong>非致命错误</strong>。</p>
</li>
<li><p>可以通过<code>&lt;&lt;</code>操作符来提供自定义的失败信息</p>
<pre><code class="cpp">ASSERT_EQ(x.size(), y.size()) &lt;&lt; &quot;Vectors x and y are of unequal length&quot;;

for (int i = 0; i &lt; x.size(); ++i) &#123;
  EXPECT_EQ(x[i], y[i]) &lt;&lt; &quot;Vectors x and y differ at index &quot; &lt;&lt; i;
&#125;
</code></pre>
</li>
</ul>
<h5 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h5><p>创建测试：</p>
<ol>
<li>使用<code>TEST()</code>宏来定义和命名一个测试函数，这些函数是没有返回值的普通函数。</li>
<li>在函数中可以使用任何有效的C++语句，可以使用不同的GTest断言来检测值。</li>
<li>测试结果由函数中的断言决定；如果有任何测试失败或者测试崩溃了，整个测试就是失败的；否则测试就是成功的。</li>
</ol>
<pre><code class="cpp">TEST(TestSuiteName, TestName) &#123;
  ... test body ...
&#125;
</code></pre>
<p>TestSuiteName和TestName都需要用有效的C++标识符代替，但是不能包含下划线！一个测试的全名由TestSuiteName和TestName组成。来自不同测试套件的测试可以有相同的<strong>个体名</strong>。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><h4 id="Task-1-Copy-On-Write-Trie"><a href="#Task-1-Copy-On-Write-Trie" class="headerlink" title="Task #1 - Copy-On-Write Trie"></a>Task #1 - Copy-On-Write Trie</h4><h5 id="Get-key"><a href="#Get-key" class="headerlink" title="Get(key)"></a>Get(key)</h5><ol>
<li>如果root_为空，直接返回nullptr</li>
<li>让node等于root_，此时可以知道node指向一个TrieNode</li>
<li>定义索引idx“指向”字符串中当前被比较的字符</li>
<li>开始循环：<ol>
<li>如果idx&#x3D;&#x3D;key.length，如果node对应结点有值，应该返回对应的值，如果node对应结点没有值，返回nullptr</li>
<li>在children中查找idx对应字符对应的结点，如果找不到返回nullptr；如果找到了，idx++，并且node应该指向找到的结点</li>
</ol>
</li>
</ol>
<h5 id="Put-key-value"><a href="#Put-key-value" class="headerlink" title="Put(key, value)"></a>Put(key, value)</h5><p>可以将这个过程分为两个过程，第一个过程是字符串字符能与结点字符匹配时对应的过程(如果字符串所有字符都能被匹配，则不需要第二个过程)，第二个过程是对不能匹配的字符序列新建子树。</p>
<p>第一个过程：</p>
<ul>
<li><p>复制root_为res，将res赋给curr_node</p>
</li>
<li><p>定义索引idx”指向”字符串中当前被比较的字符</p>
</li>
<li><p>开始循环：</p>
<ul>
<li><p>不能匹配或者idx&#x3D;&#x3D;str.len：结束循环</p>
</li>
<li><p>能匹配(即idx对应字符在curr_node的children中能找到)：curr_node的children中找到的结点设为child</p>
<ul>
<li><p>如果idx&#x3D;&#x3D;str.len-1，创建新的 TrieNodeWithValue new_child(child.children, 新的值)，然后将curr_node的children对应于idx的值修改为new_child</p>
</li>
<li><p>否则复制child为new_child，修改curr_node的children中idx对应字符的对应结点为new_child，将new_child赋给curr_node</p>
</li>
</ul>
</li>
<li><p>idx++</p>
</li>
</ul>
</li>
</ul>
<p>第二个过程：</p>
<ul>
<li><p>如果idx&#x3D;&#x3D;str.len，直接返回</p>
</li>
<li><p>否则，当idx!&#x3D;str.len时，循环：</p>
<p>令ch为str[idx]</p>
<ul>
<li>如果idx!&#x3D;str.len-1:<ul>
<li>新建Trie结点 new_child</li>
</ul>
</li>
<li>否则:<ul>
<li>新建TrieNodeWithValue new_child(新的值)</li>
</ul>
</li>
</ul>
<p>让curr_node的children中ch对应结点为new_child，curr_node&#x3D;new_child</p>
</li>
<li><p>返回Trie(res)</p>
</li>
</ul>
<h5 id="Remove-key"><a href="#Remove-key" class="headerlink" title="Remove(key)"></a>Remove(key)</h5><p>key在一个Trie中可能有下面几种状况：</p>
<ol>
<li><p>Trie中没有key，即Trie不包含key对应的路径或者key对应的结点没有值。此时删除key没有意义，应该直接返回原来的Trie。</p>
</li>
<li><p>此时可以确定key对应的结点node有值。</p>
<ul>
<li><p>如果node有孩子，则需要进行必要的结点复制操作，移除则只需要将node变成<strong>不带值结点</strong>。</p>
</li>
<li><p>如果node没有孩子，同样要进行结点复制操作，移除时需要向上找node第一个<strong>带值或者有孩子</strong>的祖先a，node到a之间的所有结点都应该被直接去掉(不包括a，但是包括node)。</p>
</li>
</ul>
</li>
</ol>
<h4 id="Task-2-Concurrent-Key-Value-Store"><a href="#Task-2-Concurrent-Key-Value-Store" class="headerlink" title="Task #2 - Concurrent Key-Value Store"></a>Task #2 - Concurrent Key-Value Store</h4></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/06/21/gdb/" title="gdb复习"><span class="has-text-weight-semibold">下一页: gdb复习</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="fertfest/fertfest.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fertfest"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> fertfest 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>清醒时做事，迷茫时读书，独处时思考，烦躁时运动，焦虑时行动，得意时淡然，失意时坦然，忙碌时专注，闲暇时蓄力。</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>