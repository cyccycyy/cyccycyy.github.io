<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>CS106L</title><meta name="description" content="热爱，专注"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="起因​	最近想做CMU 15-445，但是因为好久没写C++了，语法全忘完了，直接边学课程边回忆语法的话又没信心，干脆找了这门CS106L课程来复习C++。
​	大致看了一下课程大纲，还是能够比较全面的复习到C++知识点的。因为这门课体量比较小，就直接使用一篇笔记来记录了。
​	开搞！
​	课程官网
开发环境​	我的电脑装的是win11，但是大多数服务器装的都是linux系统，所以我打算使用vscode + wsl2的方式来学习这门课。这门课的assignments 0介绍了使用vscode进行c++开发需要的基本步骤(setup)。
1. Welcome!
课程开设时，C++版本为20。
C++: Basic Syntax + the STL。

2. Types and Structs命名空间
不使用u.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="cyy的个人记录" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">cyy's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">CS106L</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B7%E5%9B%A0"><span class="toc-text">起因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-text">开发环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Welcome"><span class="toc-text">1. Welcome!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Types-and-Structs"><span class="toc-text">2. Types and Structs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%98%AF%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-text">C++是静态类型语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-%E4%B8%80%E7%BB%84%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%80%E8%B5%B7"><span class="toc-text">struct - 一组拥有自己的名字的变量，可以将不同类型绑定到一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Initialization-and-References"><span class="toc-text">3. Initialization and References</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialization-%E4%B8%BA%E5%8F%98%E9%87%8F%E6%8F%90%E4%BE%9B%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">Initialization - 为变量提供初始值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-auto"><span class="toc-text">use auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#references-%E4%B8%80%E4%B8%AA%E5%B8%A6%E5%90%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-text">references - 一个带名变量的别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Const"><span class="toc-text">Const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Streams"><span class="toc-text">4. Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-are-streams"><span class="toc-text">What are streams?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Output-streams"><span class="toc-text">Output streams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Input-streams"><span class="toc-text">Input streams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-streams"><span class="toc-text">String streams!</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E5%9B%BD%E5%A4%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B"><i class="tag post-item-tag">国外计算机课程</i></a><a href="/tags/Cpp"><i class="tag post-item-tag">Cpp</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">CS106L</h1><time class="has-text-grey" datetime="2023-06-10T06:15:14.970Z">2023-06-10</time><article class="mt-2 post-content"><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>​	最近想做CMU 15-445，但是因为好久没写C++了，语法全忘完了，直接边学课程边回忆语法的话又没信心，干脆找了这门CS106L课程来复习C++。</p>
<p>​	大致看了一下课程大纲，还是能够比较全面的复习到C++知识点的。因为这门课体量比较小，就直接使用一篇笔记来记录了。</p>
<p>​	开搞！</p>
<p>​	<a target="_blank" rel="noopener" href="http://web.stanford.edu/class/cs106l/index.html">课程官网</a></p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>​	我的电脑装的是win11，但是大多数服务器装的都是linux系统，所以我打算使用vscode + wsl2的方式来学习这门课。这门课的assignments 0介绍了使用vscode进行c++开发需要的基本步骤(setup)。</p>
<h2 id="1-Welcome"><a href="#1-Welcome" class="headerlink" title="1. Welcome!"></a>1. Welcome!</h2><ul>
<li>课程开设时，C++版本为20。</li>
<li>C++: Basic Syntax + the STL。</li>
</ul>
<h2 id="2-Types-and-Structs"><a href="#2-Types-and-Structs" class="headerlink" title="2. Types and Structs"></a>2. Types and Structs</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul>
<li>不使用<code>using namespace std;</code></li>
<li>The namespace for the STL is std.</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li>int - 32 bits</li>
<li>char - 8 bits (usually)</li>
<li>float - 32 bits</li>
<li>double - 64 bits</li>
<li>bool - 1 bit</li>
</ul>
<h3 id="C-是静态类型语言"><a href="#C-是静态类型语言" class="headerlink" title="C++是静态类型语言"></a>C++是静态类型语言</h3><ul>
<li><p>编译型 VS 解释型</p>
<ul>
<li>主要区别：源代码什么时候被翻译<ul>
<li>源代码：代码本身</li>
<li>翻译：将源代码转换成计算机可以理解的某种东西</li>
</ul>
</li>
<li>解释型语言在运行时一行一行的被解释。(Python)</li>
<li>编译型语言在运行前统一翻译(C++)</li>
<li>静态类型帮助我们在代码运行前预防错误</li>
</ul>
</li>
<li><p>函数重载 - 参数不同的多个同名函数</p>
</li>
</ul>
<h3 id="struct-一组拥有自己的名字的变量，可以将不同类型绑定到一起"><a href="#struct-一组拥有自己的名字的变量，可以将不同类型绑定到一起" class="headerlink" title="struct - 一组拥有自己的名字的变量，可以将不同类型绑定到一起"></a>struct - 一组拥有自己的名字的变量，可以将不同类型绑定到一起</h3><pre><code class="c++">struct Student &#123;
    string name; // these are called fields
    string state; // separate these by semicolons
    int age;
&#125;;
</code></pre>
<ul>
<li><p>使用”.”来访问字段</p>
</li>
<li><p>初始化struct的简单语法：</p>
<pre><code class="c++">Student s;
s.name = &quot;Sarah&quot;;
s.state = &quot;CA&quot;;
s.age = 21;
//is the same as ...
Student s = &#123;&quot;Sarah&quot;, &quot;CA&quot;, 21&#125;;
</code></pre>
</li>
<li><p>std::pair - 一个STL内置结构体，带有两个字段，两个字段可以是任何类型。</p>
<ul>
<li><p>std::pair是一个模板</p>
</li>
<li><p>使用make_pair来创造pair</p>
<pre><code class="c++">return std::make_pair(true, result);
</code></pre>
</li>
</ul>
</li>
<li><p>auto(关键词) - 类型推断</p>
<ul>
<li>使用auto不代表变量没有类型，而是代表变量类型由编译器推导。、</li>
</ul>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>程序中<strong>每一个</strong>有名字的东西都有它的类型</p>
</li>
<li><p>静态类型在代码运行前预防错误</p>
</li>
<li><p>结构体是一种将多个变量捆绑到一起的方式</p>
</li>
<li><p>std::pair是一种已经在STL中定义的结构体，可以通过std:: 命名空间访问</p>
</li>
<li><p>auto是一个关键字，用于告诉编译器让它推断一个变量的类型。在类型很明显或者类型写出来很麻烦时使用</p>
</li>
<li><p>quadratic.cpp</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt; //gives us pow and sqrt!

using std::cin;
using std::cout;
using std::endl;
using std::make_pair;
using std::pair;
using std::pow;
using std::sqrt;
using std::string;

// want: a function named quadratic that will take in 3 doubles and return
// a combination of: does a solution exist, and if so, what is it?
// get radical, test if negative, return indicating no roots
//  radical = b^2 - 4ac

// otherwise get roots and return
//  root1 = (-b + sqrt(radical)) divided by 2a
//  root2 = (-b - sqrt(radical)) divided by 2a

pair&lt;bool, pair&lt;double, double&gt;&gt; quadratic(double a, double b, double c)
&#123;
    double radical = pow(b, 2.0) - 4 * a * c;
    if (radical &lt; 0)
    &#123;
        return make_pair(false, make_pair(0, 0));
    &#125;
    double root1 = (-b + sqrt(radical)) / (2 * a);
    double root2 = (-b - sqrt(radical)) / (2 * a);
    return make_pair(true, make_pair(root1, root2));
&#125;

int main()
&#123;
    // get 3 doubles (ax^2 + bx + c)
    double a, b, c;
    cout &lt;&lt; &quot;Give me 3 coefficients: &quot; &lt;&lt; endl;

    // This line gets 3 numbers from user input and stores them in a, b and c
    // we will learn more about cin on Thursday
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    // some call to quadratic function!
    auto res = quadratic(a, b, c);
    bool flag = res.first;

    // get roots if they exist
    if (!flag)
    &#123;
        cout &lt;&lt; &quot;No solution!&quot;;
        return 0;
    &#125;

    double r1 = res.second.first;
    double r2 = res.second.second;

    // print accordingly
    cout &lt;&lt; &quot;root1: &quot; &lt;&lt; r1 &lt;&lt; &quot; root2: &quot; &lt;&lt; r2;
    return 0;
&#125;

// Test: x^2 + 5x + 6 = 0, roots = -3, -2

// To run: first compile code --&gt; make quadratic,
// then run the compiled code --&gt; ./quadratic
</code></pre>
</li>
</ul>
<h2 id="3-Initialization-and-References"><a href="#3-Initialization-and-References" class="headerlink" title="3. Initialization and References"></a>3. Initialization and References</h2><h3 id="Initialization-为变量提供初始值"><a href="#Initialization-为变量提供初始值" class="headerlink" title="Initialization - 为变量提供初始值"></a>Initialization - 为变量提供初始值</h3><ul>
<li><p>uniform initialization: 花括号初始化，对所有类型可用，在声明时立即初始化</p>
<ul>
<li><p>初始化vector时要小心</p>
<pre><code class="cpp">std::vector&lt;int&gt; vec1(3,5);
// makes &#123;5, 5, 5&#125;, not &#123;3, 5&#125;!
// uses a std::initializer_list (more later)
std::vector&lt;int&gt; vec2&#123;3,5&#125;;
// makes &#123;3, 5&#125;
</code></pre>
</li>
<li><p><strong>使用统一初始化来初始化你的每一个非主类型字段</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="use-auto"><a href="#use-auto" class="headerlink" title="use auto"></a>use auto</h3><ul>
<li><p>不要过度使用auto - 简单类型直接写出来</p>
</li>
<li><p>Structured Binding</p>
<ul>
<li><p>Before</p>
<pre><code class="c++">auto p =
std::make_pair(“s”, 5);
string a = p.first;
int b = p.second;
</code></pre>
</li>
<li><p>After</p>
<pre><code class="c++">auto p = std::make_pair(“s”, 5);
auto [a, b] = p;
// a is string, b is int
// auto [a, b] =
std::make_pair(...);
</code></pre>
</li>
<li><p>cleaner quadratic</p>
<pre><code class="c++">auto [found, solutions] = quadratic(a, b, c);
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="references-一个带名变量的别名"><a href="#references-一个带名变量的别名" class="headerlink" title="references - 一个带名变量的别名"></a>references - 一个带名变量的别名</h3><ul>
<li><p>经典的引用-拷贝bug 1.0：</p>
<pre><code class="c++">void shift(vector&lt;std::pair&lt;int, int&gt;&gt;&amp; nums) &#123;
    for (size_t i = 0; i &lt; nums.size(); ++i) &#123;
        auto [num1, num2] = nums[i];
        num1++;
        num2++;
    &#125;
&#125;

//修正
//auto [num1, num2] = nums[i]; -&gt; auto&amp; [num1, num2] = nums[i];
</code></pre>
<ul>
<li>size_t 常被用于索引，因为它是无符号的并且有着动态的大小</li>
<li>++i 和 i++ 不再有性能区别</li>
</ul>
</li>
<li><p>经典的引用-拷贝bug 2.0：</p>
<pre><code class="c++">void shift(vector&lt;std::pair&lt;int, int&gt;&gt;&amp; nums) &#123;
    for (auto [num1, num2]: nums) &#123;
        num1++;
        num2++;
    &#125;
&#125;

//修正
//auto [num1, num2]: nums -&gt; auto&amp; [num1, num2]: nums
</code></pre>
</li>
<li><p>l-values vs r-values</p>
<ul>
<li><p>l-values 可以出现在<strong>赋值号</strong>左边或右边， l-values不是临时的</p>
<pre><code>int x = 3;//x is a l-value
int y = x;
</code></pre>
</li>
<li><p>r-values 只能出现在等号右边，r-values是临时的</p>
<pre><code>int x = 3;//3 is a r-value
int y = x;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><ul>
<li>Const and Const References<ul>
<li>const表明一个变量不能被修改，const变量<strong>可以</strong>被引用</li>
</ul>
</li>
<li>当我们进行变量赋值时，C++默认情况下会进行拷贝。如果需要引用就使用&amp;<ul>
<li>如果对一个几乎不占空间的变量进行操作，不需要使用引用，直接拷贝变量就好</li>
<li>如果我们需要为变量起别名来修改变量，可以使用引用</li>
<li>如果不需要修改变量，但是变量很占空间，可以使用const引用</li>
</ul>
</li>
</ul>
<h2 id="4-Streams"><a href="#4-Streams" class="headerlink" title="4. Streams"></a>4. Streams</h2><h3 id="What-are-streams"><a href="#What-are-streams" class="headerlink" title="What are streams?"></a>What are streams?</h3><ul>
<li><p>definition</p>
<p>stream: 对I&#x2F;O的一个抽象。流对数据和数据的串表示进行相互转换。</p>
</li>
<li><p>std::cout是一个输出流，它有着std::ostream类型</p>
</li>
<li><p>流的分类</p>
<p><img src="/../images/CS106L/4.1.%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="流的分类"></p>
</li>
</ul>
<h3 id="Output-streams"><a href="#Output-streams" class="headerlink" title="Output streams"></a>Output streams</h3><ul>
<li>类型为std::ostream</li>
<li>只能发送数据到流</li>
<li>std::cout是一个全局常量对象</li>
<li>ofstream</li>
</ul>
<h3 id="Input-streams"><a href="#Input-streams" class="headerlink" title="Input streams"></a>Input streams</h3><ul>
<li><p>“&gt;&gt;”是流提取操作符，用于从一个流中提取数据并把数据放到变量中</p>
</li>
<li><p>“&lt;&lt;”是流插入操作符，用来插入数据到流中</p>
</li>
<li><p>类型为std::istream</p>
</li>
<li><p>输入流接收到错误的数据（例如数据类型不匹配）</p>
<p>一旦一个错误被检测到，输入流的fail bit会被设置，它就不会再接收输入。</p>
</li>
<li><pre><code class="c++">istream&amp; getline(istream&amp; is, string&amp; str, char delim);
</code></pre>
</li>
<li><p><strong>重要提示</strong>：不要将”&gt;&gt;”和getline混用！</p>
<ul>
<li>“&gt;&gt;”读取下一个空白符之前的内容，不会跳过空白符</li>
<li>“getline”读取下一个界定符前的内容，并且会跳过界定符</li>
</ul>
</li>
<li><p>ifstream</p>
</li>
<li><p>std::cin是一个全局常量对象</p>
</li>
</ul>
<h3 id="String-streams"><a href="#String-streams" class="headerlink" title="String streams!"></a>String streams!</h3><ul>
<li>Stringstream是一个流，可以从一个string对象中读取数据或者向string对象写入数据。</li>
<li>只读流：istringstream</li>
<li>只写流：ostringstream</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/06/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ETreeMap%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/" title="记一次关于TreeMap的使用的坑"><span class="has-text-weight-semibold">下一页: 记一次关于TreeMap的使用的坑</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="cyccycyy/cyccycyy.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/cyccycyy"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> cyy 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>清醒时做事，迷茫时读书，独处时思考，烦躁时运动，焦虑时行动，得意时淡然，失意时坦然，忙碌时专注，闲暇时蓄力。</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>