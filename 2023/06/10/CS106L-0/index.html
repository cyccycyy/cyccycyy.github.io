<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>CS106L</title><meta name="description" content="热爱，专注"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="起因​	最近想做CMU 15-445，但是因为好久没写C++了，语法全忘完了，直接边学课程边回忆语法的话又没信心，干脆找了这门CS106L课程来复习C++。
​	大致看了一下课程大纲，还是能够比较全面的复习到C++知识点的。因为这门课体量比较小，就直接使用一篇笔记来记录了。
​	开搞！
​	课程官网
开发环境​	我的电脑装的是win11，但是大多数服务器装的都是linux系统，所以我打算使用vscode + wsl2的方式来学习这门课。这门课的assignments 0介绍了使用vscode进行c++开发需要的基本步骤(setup)。
1. Welcome!
课程开设时，C++版本为20。
C++: Basic Syntax + the STL。

2. Types and Structs命名空间
不使用u.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="fertfest的个人记录" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">fertfest's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">CS106L</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B7%E5%9B%A0"><span class="toc-text">起因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-text">开发环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Welcome"><span class="toc-text">1. Welcome!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Types-and-Structs"><span class="toc-text">2. Types and Structs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%98%AF%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-text">C++是静态类型语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-%E4%B8%80%E7%BB%84%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%80%E8%B5%B7"><span class="toc-text">struct - 一组拥有自己的名字的变量，可以将不同类型绑定到一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Initialization-and-References"><span class="toc-text">3. Initialization and References</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialization-%E4%B8%BA%E5%8F%98%E9%87%8F%E6%8F%90%E4%BE%9B%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">Initialization - 为变量提供初始值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-auto"><span class="toc-text">use auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#references-%E4%B8%80%E4%B8%AA%E5%B8%A6%E5%90%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-text">references - 一个带名变量的别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Const"><span class="toc-text">Const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Streams"><span class="toc-text">4. Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-are-streams"><span class="toc-text">What are streams?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Output-streams"><span class="toc-text">Output streams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Input-streams"><span class="toc-text">Input streams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-streams"><span class="toc-text">String streams!</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Containers"><span class="toc-text">5. Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-Containers"><span class="toc-text">Defining Containers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Containers-in-the-STL-vs-Stanford"><span class="toc-text">Containers in the STL vs Stanford</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Container-Adaptors"><span class="toc-text">Container Adaptors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Iterators-and-Pointers"><span class="toc-text">6. Iterators and Pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterators"><span class="toc-text">Iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointers"><span class="toc-text">Pointers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Classes"><span class="toc-text">7. Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Definition"><span class="toc-text">Definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-not-structs%EF%BC%9F"><span class="toc-text">Why not structs？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-this-keyword"><span class="toc-text">The this keyword</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructors-1-0"><span class="toc-text">Constructors 1.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructors-2-0"><span class="toc-text">Constructors 2.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructors-3-0"><span class="toc-text">Constructors 3.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Aside%E2%80%A6-Arrays"><span class="toc-text">Aside… Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Destructors"><span class="toc-text">Destructors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Classes-intro"><span class="toc-text">Template Classes (intro)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-sneaky-bug"><span class="toc-text">A sneaky bug</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Template-Classes-and-Const-Correctness"><span class="toc-text">8. Template Classes and Const Correctness</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Member-Types"><span class="toc-text">Member Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-summary"><span class="toc-text">Template summary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Const-Correctness"><span class="toc-text">Const Correctness</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Template-Functions"><span class="toc-text">9. Template Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Functions"><span class="toc-text">Template Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-metaprogramming"><span class="toc-text">Template metaprogramming</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction-to-Algorithms"><span class="toc-text">Introduction to Algorithms</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Functions-and-Lambdas"><span class="toc-text">10. Functions and Lambdas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions-and-Lambdas"><span class="toc-text">Functions and Lambdas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithms"><span class="toc-text">Algorithms</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Operators"><span class="toc-text">11. Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Operators-and-Operator-Overloading"><span class="toc-text">Operators and Operator Overloading</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Special-Member-Functions"><span class="toc-text">12. Special Member Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview"><span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-and-copy-assignment"><span class="toc-text">Copy and copy assignment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Default-and-delete"><span class="toc-text">Default and delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move-and-move-assignment"><span class="toc-text">Move and move assignment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Move-Semantics"><span class="toc-text">13. Move Semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#L-values-vs-r-values"><span class="toc-text">L values vs r values</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#What-the-heck-is-amp-amp"><span class="toc-text">What the heck is &amp;&amp;??</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ESMF%E7%9A%84%E4%B8%80%E4%BA%9B%E5%93%B2%E5%AD%A6"><span class="toc-text">关于SMF的一些哲学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E5%87%A0%E7%AF%87%E6%96%87%E7%AB%A0"><span class="toc-text">关于移动语义的几篇文章</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-std-optional-and-Type-Safety"><span class="toc-text">14. std::optional and Type Safety</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Introducing-std-optional"><span class="toc-text">Introducing std::optional</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-RAII-Smart-Pointers-and-Building-C-Projects"><span class="toc-text">15. RAII, Smart Pointers, and Building C++ Projects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII-A-coding-standard-and-practice"><span class="toc-text">RAII - A coding standard and practice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smart-Pointers"><span class="toc-text">Smart Pointers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Building-C-Projects"><span class="toc-text">Building C++ Projects</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E5%9B%BD%E5%A4%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B"><i class="tag post-item-tag">国外计算机课程</i></a><a href="/tags/Cpp"><i class="tag post-item-tag">Cpp</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">CS106L</h1><time class="has-text-grey" datetime="2023-06-10T06:15:14.970Z">2023-06-10</time><article class="mt-2 post-content"><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>​	最近想做CMU 15-445，但是因为好久没写C++了，语法全忘完了，直接边学课程边回忆语法的话又没信心，干脆找了这门CS106L课程来复习C++。</p>
<p>​	大致看了一下课程大纲，还是能够比较全面的复习到C++知识点的。因为这门课体量比较小，就直接使用一篇笔记来记录了。</p>
<p>​	开搞！</p>
<p>​	<a target="_blank" rel="noopener" href="http://web.stanford.edu/class/cs106l/index.html">课程官网</a></p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>​	我的电脑装的是win11，但是大多数服务器装的都是linux系统，所以我打算使用vscode + wsl2的方式来学习这门课。这门课的assignments 0介绍了使用vscode进行c++开发需要的基本步骤(setup)。</p>
<h2 id="1-Welcome"><a href="#1-Welcome" class="headerlink" title="1. Welcome!"></a>1. Welcome!</h2><ul>
<li>课程开设时，C++版本为20。</li>
<li>C++: Basic Syntax + the STL。</li>
</ul>
<h2 id="2-Types-and-Structs"><a href="#2-Types-and-Structs" class="headerlink" title="2. Types and Structs"></a>2. Types and Structs</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul>
<li>不使用<code>using namespace std;</code></li>
<li>The namespace for the STL is std.</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li>int - 32 bits</li>
<li>char - 8 bits (usually)</li>
<li>float - 32 bits</li>
<li>double - 64 bits</li>
<li>bool - 1 bit</li>
</ul>
<h3 id="C-是静态类型语言"><a href="#C-是静态类型语言" class="headerlink" title="C++是静态类型语言"></a>C++是静态类型语言</h3><ul>
<li><p>编译型 VS 解释型</p>
<ul>
<li>主要区别：源代码什么时候被翻译<ul>
<li>源代码：代码本身</li>
<li>翻译：将源代码转换成计算机可以理解的某种东西</li>
</ul>
</li>
<li>解释型语言在运行时一行一行的被解释。(Python)</li>
<li>编译型语言在运行前统一翻译(C++)</li>
<li>静态类型帮助我们在代码运行前预防错误</li>
</ul>
</li>
<li><p>函数重载 - 参数不同的多个同名函数</p>
</li>
</ul>
<h3 id="struct-一组拥有自己的名字的变量，可以将不同类型绑定到一起"><a href="#struct-一组拥有自己的名字的变量，可以将不同类型绑定到一起" class="headerlink" title="struct - 一组拥有自己的名字的变量，可以将不同类型绑定到一起"></a>struct - 一组拥有自己的名字的变量，可以将不同类型绑定到一起</h3><pre><code class="c++">struct Student &#123;
    string name; // these are called fields
    string state; // separate these by semicolons
    int age;
&#125;;
</code></pre>
<ul>
<li><p>使用”.”来访问字段</p>
</li>
<li><p>初始化struct的简单语法：</p>
<pre><code class="c++">Student s;
s.name = &quot;Sarah&quot;;
s.state = &quot;CA&quot;;
s.age = 21;
//is the same as ...
Student s = &#123;&quot;Sarah&quot;, &quot;CA&quot;, 21&#125;;
</code></pre>
</li>
<li><p>std::pair - 一个STL内置结构体，带有两个字段，两个字段可以是任何类型。</p>
<ul>
<li><p>std::pair是一个模板</p>
</li>
<li><p>使用make_pair来创造pair</p>
<pre><code class="c++">return std::make_pair(true, result);
</code></pre>
</li>
</ul>
</li>
<li><p>auto(关键词) - 类型推断</p>
<ul>
<li>使用auto不代表变量没有类型，而是代表变量类型由编译器推导。、</li>
</ul>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>程序中<strong>每一个</strong>有名字的东西都有它的类型</p>
</li>
<li><p>静态类型在代码运行前预防错误</p>
</li>
<li><p>结构体是一种将多个变量捆绑到一起的方式</p>
</li>
<li><p>std::pair是一种已经在STL中定义的结构体，可以通过std:: 命名空间访问</p>
</li>
<li><p>auto是一个关键字，用于告诉编译器让它推断一个变量的类型。在类型很明显或者类型写出来很麻烦时使用</p>
</li>
<li><p>quadratic.cpp</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt; //gives us pow and sqrt!

using std::cin;
using std::cout;
using std::endl;
using std::make_pair;
using std::pair;
using std::pow;
using std::sqrt;
using std::string;

// want: a function named quadratic that will take in 3 doubles and return
// a combination of: does a solution exist, and if so, what is it?
// get radical, test if negative, return indicating no roots
//  radical = b^2 - 4ac

// otherwise get roots and return
//  root1 = (-b + sqrt(radical)) divided by 2a
//  root2 = (-b - sqrt(radical)) divided by 2a

pair&lt;bool, pair&lt;double, double&gt;&gt; quadratic(double a, double b, double c)
&#123;
    double radical = pow(b, 2.0) - 4 * a * c;
    if (radical &lt; 0)
    &#123;
        return make_pair(false, make_pair(0, 0));
    &#125;
    double root1 = (-b + sqrt(radical)) / (2 * a);
    double root2 = (-b - sqrt(radical)) / (2 * a);
    return make_pair(true, make_pair(root1, root2));
&#125;

int main()
&#123;
    // get 3 doubles (ax^2 + bx + c)
    double a, b, c;
    cout &lt;&lt; &quot;Give me 3 coefficients: &quot; &lt;&lt; endl;

    // This line gets 3 numbers from user input and stores them in a, b and c
    // we will learn more about cin on Thursday
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    // some call to quadratic function!
    auto res = quadratic(a, b, c);
    bool flag = res.first;

    // get roots if they exist
    if (!flag)
    &#123;
        cout &lt;&lt; &quot;No solution!&quot;;
        return 0;
    &#125;

    double r1 = res.second.first;
    double r2 = res.second.second;

    // print accordingly
    cout &lt;&lt; &quot;root1: &quot; &lt;&lt; r1 &lt;&lt; &quot; root2: &quot; &lt;&lt; r2;
    return 0;
&#125;

// Test: x^2 + 5x + 6 = 0, roots = -3, -2

// To run: first compile code --&gt; make quadratic,
// then run the compiled code --&gt; ./quadratic
</code></pre>
</li>
</ul>
<h2 id="3-Initialization-and-References"><a href="#3-Initialization-and-References" class="headerlink" title="3. Initialization and References"></a>3. Initialization and References</h2><h3 id="Initialization-为变量提供初始值"><a href="#Initialization-为变量提供初始值" class="headerlink" title="Initialization - 为变量提供初始值"></a>Initialization - 为变量提供初始值</h3><ul>
<li><p>uniform initialization: 花括号初始化，对所有类型可用，在声明时立即初始化</p>
<ul>
<li><p>初始化vector时要小心</p>
<pre><code class="cpp">std::vector&lt;int&gt; vec1(3,5);
// makes &#123;5, 5, 5&#125;, not &#123;3, 5&#125;!
// uses a std::initializer_list (more later)
std::vector&lt;int&gt; vec2&#123;3,5&#125;;
// makes &#123;3, 5&#125;
</code></pre>
</li>
<li><p><strong>使用统一初始化来初始化你的每一个非主类型字段</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="use-auto"><a href="#use-auto" class="headerlink" title="use auto"></a>use auto</h3><ul>
<li><p>不要过度使用auto - 简单类型直接写出来</p>
</li>
<li><p>Structured Binding</p>
<ul>
<li><p>Before</p>
<pre><code class="c++">auto p =
std::make_pair(“s”, 5);
string a = p.first;
int b = p.second;
</code></pre>
</li>
<li><p>After</p>
<pre><code class="c++">auto p = std::make_pair(“s”, 5);
auto [a, b] = p;
// a is string, b is int
// auto [a, b] =
std::make_pair(...);
</code></pre>
</li>
<li><p>cleaner quadratic</p>
<pre><code class="c++">auto [found, solutions] = quadratic(a, b, c);
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="references-一个带名变量的别名"><a href="#references-一个带名变量的别名" class="headerlink" title="references - 一个带名变量的别名"></a>references - 一个带名变量的别名</h3><ul>
<li><p>经典的引用-拷贝bug 1.0：</p>
<pre><code class="c++">void shift(vector&lt;std::pair&lt;int, int&gt;&gt;&amp; nums) &#123;
    for (size_t i = 0; i &lt; nums.size(); ++i) &#123;
        auto [num1, num2] = nums[i];
        num1++;
        num2++;
    &#125;
&#125;

//修正
//auto [num1, num2] = nums[i]; -&gt; auto&amp; [num1, num2] = nums[i];
</code></pre>
<ul>
<li>size_t 常被用于索引，因为它是无符号的并且有着动态的大小</li>
<li>++i 和 i++ 不再有性能区别</li>
</ul>
</li>
<li><p>经典的引用-拷贝bug 2.0：</p>
<pre><code class="c++">void shift(vector&lt;std::pair&lt;int, int&gt;&gt;&amp; nums) &#123;
    for (auto [num1, num2]: nums) &#123;
        num1++;
        num2++;
    &#125;
&#125;

//修正
//auto [num1, num2]: nums -&gt; auto&amp; [num1, num2]: nums
</code></pre>
</li>
<li><p>l-values vs r-values</p>
<ul>
<li><p>l-values 可以出现在<strong>赋值号</strong>左边或右边， l-values不是临时的</p>
<pre><code>int x = 3;//x is a l-value
int y = x;
</code></pre>
</li>
<li><p>r-values 只能出现在等号右边，r-values是临时的</p>
<pre><code>int x = 3;//3 is a r-value
int y = x;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><ul>
<li>Const and Const References<ul>
<li>const表明一个变量不能被修改，const变量<strong>可以</strong>被引用</li>
</ul>
</li>
<li>当我们进行变量赋值时，C++默认情况下会进行拷贝。如果需要引用就使用&amp;<ul>
<li>如果对一个几乎不占空间的变量进行操作，不需要使用引用，直接拷贝变量就好</li>
<li>如果我们需要为变量起别名来修改变量，可以使用引用</li>
<li>如果不需要修改变量，但是变量很占空间，可以使用const引用</li>
</ul>
</li>
</ul>
<h2 id="4-Streams"><a href="#4-Streams" class="headerlink" title="4. Streams"></a>4. Streams</h2><h3 id="What-are-streams"><a href="#What-are-streams" class="headerlink" title="What are streams?"></a>What are streams?</h3><ul>
<li><p>definition</p>
<p>stream: 对I&#x2F;O的一个抽象。流对数据和数据的串表示进行相互转换。</p>
</li>
<li><p>std::cout是一个输出流，它有着std::ostream类型</p>
</li>
<li><p>流的分类</p>
<p><img src="/../images/CS106L/4.1.%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="流的分类"></p>
</li>
</ul>
<h3 id="Output-streams"><a href="#Output-streams" class="headerlink" title="Output streams"></a>Output streams</h3><ul>
<li>类型为std::ostream</li>
<li>只能发送数据到流</li>
<li>std::cout是一个全局常量对象</li>
<li>ofstream</li>
</ul>
<h3 id="Input-streams"><a href="#Input-streams" class="headerlink" title="Input streams"></a>Input streams</h3><ul>
<li><p>“&gt;&gt;”是流提取操作符，用于从一个流中提取数据并把数据放到变量中</p>
</li>
<li><p>“&lt;&lt;”是流插入操作符，用来插入数据到流中</p>
</li>
<li><p>类型为std::istream</p>
</li>
<li><p>输入流接收到错误的数据（例如数据类型不匹配）</p>
<p>一旦一个错误被检测到，输入流的fail bit会被设置，它就不会再接收输入。</p>
</li>
<li><pre><code class="c++">istream&amp; getline(istream&amp; is, string&amp; str, char delim);
</code></pre>
</li>
<li><p><strong>重要提示</strong>：不要将”&gt;&gt;”和getline混用！</p>
<ul>
<li>“&gt;&gt;”读取下一个空白符之前的内容，不会跳过空白符</li>
<li>“getline”读取下一个界定符前的内容，并且会跳过界定符</li>
</ul>
</li>
<li><p>ifstream</p>
</li>
<li><p>std::cin是一个全局常量对象</p>
</li>
</ul>
<h3 id="String-streams"><a href="#String-streams" class="headerlink" title="String streams!"></a>String streams!</h3><ul>
<li>Stringstream是一个流，可以从一个string对象中读取数据或者向string对象写入数据。</li>
<li>只读流：istringstream</li>
<li>只写流：ostringstream</li>
</ul>
<h2 id="5-Containers"><a href="#5-Containers" class="headerlink" title="5. Containers"></a>5. Containers</h2><h3 id="Defining-Containers"><a href="#Defining-Containers" class="headerlink" title="Defining Containers"></a>Defining Containers</h3><p>允许我们将其它对象收集到一起并且以某种方式与它们交互的对象。</p>
<h3 id="Containers-in-the-STL-vs-Stanford"><a href="#Containers-in-the-STL-vs-Stanford" class="headerlink" title="Containers in the STL vs Stanford"></a>Containers in the STL vs Stanford</h3><ul>
<li><p>C++设计哲学</p>
<ul>
<li>Only provide the checks&#x2F;safety nets that are necessary</li>
<li>The programmer knows best!</li>
</ul>
<p>这里我觉得大致意思就是说C++对程序员要求很高。</p>
</li>
<li><p>两种容器 - 顺序容器&amp;关联容器</p>
</li>
<li><p>Vector 实现</p>
<p>内部使用数组实现，需要追踪几个变量：</p>
<ul>
<li>_size &#x3D; vector中元素的个数</li>
<li>_capacity &#x3D; 已分配给元素们的空间</li>
</ul>
</li>
<li><p>序列容器对比：</p>
<p><img src="/../images/CS106L/5.1.%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E5%AF%B9%E6%AF%94.png" alt="序列容器对比"></p>
</li>
<li><p>序列容器总结：</p>
<ul>
<li>当你要求数据保持某种顺序时使用顺序容器</li>
<li><strong>std::vector适用于绝大多数场景</strong></li>
<li>如果需要非常快的头插速度，考虑使用std::deque</li>
<li>需要多个列表时考虑std::list</li>
</ul>
</li>
<li><p>Map实现</p>
<p>Map实现借助了pair(std::pair&lt;const key, value&gt;)</p>
<ul>
<li>注意key不可变</li>
<li>通过myMap[key]搜索key对应的value</li>
</ul>
</li>
<li><p>无序关联容器</p>
<p>map和set都有无序(unordered)版本</p>
<ul>
<li>有序关联容器需要定义<strong>比较操作符</strong></li>
<li>无序关联容器需要定义<strong>哈希函数</strong>(简单类型已经提供原生支持，其它类型需要自己定义)</li>
</ul>
<p>无序版本通常更快</p>
</li>
<li><p>选择关联容器</p>
<ul>
<li>无序容器更快，但是需要嵌套容器或集合时使用很困难</li>
<li>如果使用复合数据类型或者对哈希函数不熟悉，使用有序关联容器</li>
</ul>
</li>
</ul>
<h3 id="Container-Adaptors"><a href="#Container-Adaptors" class="headerlink" title="Container Adaptors"></a>Container Adaptors</h3><ul>
<li>容器适应器是现有容器的<strong>包装器</strong>！<ul>
<li>容器修改对序列容器的接口，改变客户能对容器执行的操作。</li>
</ul>
</li>
</ul>
<h2 id="6-Iterators-and-Pointers"><a href="#6-Iterators-and-Pointers" class="headerlink" title="6. Iterators and Pointers"></a>6. Iterators and Pointers</h2><h3 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h3><ul>
<li><p>迭代器介绍</p>
<p>容器都实现了叫做迭代器的东西来遍历容器</p>
<ul>
<li>迭代器让你可以编程式地访问容器中的数据！</li>
<li>迭代器有确定的顺序，它知道下一个到来的元素是什么</li>
</ul>
</li>
<li><p>STL中的迭代器</p>
<ul>
<li>每个容器都有自己的迭代器，这些迭代器可能有不同的行为</li>
<li>所有迭代器都有一些共同的操作：<ul>
<li>初始化</li>
<li>自增</li>
<li>解引用</li>
<li>比较</li>
<li>拷贝</li>
</ul>
</li>
</ul>
</li>
<li><p>迭代器等级</p>
<p><img src="/..%5Cimages%5CCS106L%5C5.2.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%AD%89%E7%BA%A7.png" alt="5.2.迭代器等级"></p>
<p><strong>前向迭代器</strong>是标准容器的最低功能等级</p>
<ul>
<li>输入迭代器可以出现在赋值号右边</li>
<li>输出迭代器可以出现在赋值号左边</li>
<li>双向迭代器可以向前也可以向后，同时有前向迭代器的所有功能</li>
<li>随机访问迭代器可以随机访问容器元素，同时有双向迭代器的所有功能，使用时要注意访问越界问题</li>
</ul>
<p>STL迭代器等级一览：</p>
<p><img src="/..%5Cimages%5CCS106L%5C5.3.STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%AD%89%E7%BA%A7.png" alt="5.3.STL迭代器等级"></p>
</li>
</ul>
<h3 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h3><p>迭代器是一种特定类型的指针</p>
<ul>
<li>迭代器“指向”容器中的特定元素</li>
<li>指针可以“指向”代码中的任何对象</li>
</ul>
<h2 id="7-Classes"><a href="#7-Classes" class="headerlink" title="7. Classes"></a>7. Classes</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>程序员定义的自定义类型。一个对象或者数据类型的抽象。</p>
<h3 id="Why-not-structs？"><a href="#Why-not-structs？" class="headerlink" title="Why not structs？"></a>Why not structs？</h3><ul>
<li><p>使用struct时存在的问题</p>
<ul>
<li>默认对所有内部状态是public访问权限</li>
<li>struct的使用者需要显式初始化每一个数据成员</li>
</ul>
</li>
<li><p>By Bjarne Stroustrup</p>
<p>“A struct simply feels like an open pile of bits with very little in the way of encapsulation or functionality. A class feels like a living and responsible member of society with intelligent services, a strong encapsulation barrier, and a well defined interface.”</p>
</li>
</ul>
<h3 id="The-this-keyword"><a href="#The-this-keyword" class="headerlink" title="The this keyword"></a>The this keyword</h3><ul>
<li>this-&gt;element_name表示“此对象中名字为element_name的项”</li>
</ul>
<h3 id="Constructors-1-0"><a href="#Constructors-1-0" class="headerlink" title="Constructors 1.0"></a>Constructors 1.0</h3><pre><code class="cpp">//student.cpp
#include student.h
Student::Student()&#123;
    age = 0;
    name = “”;
    state = “”;
&#125; 
</code></pre>
<ul>
<li>定义一个对象的成员变量如何被初始化</li>
<li>当你第一次创建一个对象时执行什么操作</li>
</ul>
<h3 id="Constructors-2-0"><a href="#Constructors-2-0" class="headerlink" title="Constructors 2.0"></a>Constructors 2.0</h3><pre><code class="cpp">//student.cpp
#include student.h
Student::Student()&#123;...&#125;
Student::Student(string name, int age, string state)&#123;
    this-&gt;name = name;
    this-&gt;age = age;
    this-&gt;state = state;
&#125;
</code></pre>
<ul>
<li>可重载!</li>
</ul>
<h3 id="Constructors-3-0"><a href="#Constructors-3-0" class="headerlink" title="Constructors 3.0"></a>Constructors 3.0</h3><pre><code class="cpp">//student.cpp
#include student.h
Student::Student() : name&#123;&quot;&quot;&#125;, age&#123;0&#125;, state&#123;&quot;&quot;&#125; &#123;&#125;
Student::Student(string name, int age, string state) :
name&#123;name&#125;, age&#123;name&#125;, state&#123;state&#125; &#123;&#125;
</code></pre>
<ul>
<li>使用初始化列表快速地构造对象！</li>
</ul>
<h3 id="Aside…-Arrays"><a href="#Aside…-Arrays" class="headerlink" title="Aside… Arrays"></a>Aside… Arrays</h3><ul>
<li>数组是一种主类型！他们是所有容器的构建模块(building blocks)</li>
<li>把数组当做你可以进行索引操作的固定大小的对象列表</li>
<li>把数组当做vector的struct版本。<strong>你不应该在程序代码中使用它们</strong>！Vectors是数组的STL接口！</li>
</ul>
<h3 id="Destructors"><a href="#Destructors" class="headerlink" title="Destructors"></a>Destructors</h3><ul>
<li>delete总是发生在一个类的析构器中！</li>
<li>析构器用Class_name::~Class_name()定义</li>
<li>析构器不需要显式调用！当Class_name对象超出范围时被调用！</li>
<li><strong>就像所有的成员函数一样，在.h中声明它然后在.cpp中实现它！</strong></li>
<li>记得要释放内存！</li>
</ul>
<h3 id="Template-Classes-intro"><a href="#Template-Classes-intro" class="headerlink" title="Template Classes (intro)"></a>Template Classes (intro)</h3><p>定义：模板类：某些类型被参数化的类。由通用类型成员变量组成的类</p>
<p>软件工程的基本理论：任何问题都可以通过添加足够多的中间层解决</p>
<p>基本语法：</p>
<pre><code class="cpp">//mypair.h
template&lt;typename First, typename Second&gt; class MyPair &#123;
    public:
    First getFirst();
    Second getSecond();
    void setFirst(First f);
    void setSecond(Second f);
    private:
    First first;
    Second second;
&#125;;
</code></pre>
<pre><code class="cpp">//mypair.cpp
#include “mypair.h”
template&lt;typename First, typename Second&gt;
First MyPair::getFirst()&#123;
    return first;
&#125;
template&lt;typename Second, typename First&gt;
Second MyPair::getSecond()&#123;
    return second;
&#125;
</code></pre>
<h3 id="A-sneaky-bug"><a href="#A-sneaky-bug" class="headerlink" title="A sneaky bug"></a>A sneaky bug</h3><ul>
<li><p>模板在实例化前不会产生代码，所以要把.cpp文件在.h中include！</p>
</li>
<li><p>C++编译器处理<strong>非模板</strong>类：</p>
<pre><code class="cpp">// main.cpp
#include “vectorint.h”
vectorInt a;
a.at(5);
</code></pre>
<ol>
<li><pre><code class="shell">g++ -c vectorint.cpp main.cpp
</code></pre>
<p>编译并且创建所有vectorint.cpp 和 main.cpp中的代码。现在所有vectorint.h中的函数都有了已经被编译过的实现，main可以访问它们，因为它包含vectorint.h</p>
</li>
<li><p>使用vectorInt::at，因为at的实现已经编译过，现在可以使用它！</p>
</li>
</ol>
</li>
<li><p>C++编译器处理<strong>模板</strong>类：</p>
<pre><code class="cpp">// main.cpp
#include “vector.h”
vector a;
a.at(5);
</code></pre>
<ol>
<li><pre><code class="shell">g++ -c vector.cpp main.cpp:
</code></pre>
<p>编译并创建所有main.cpp中的代码。编译vector.cpp，但是因为它是一个模板，不会创建任何代码</p>
</li>
<li><p>创建vector&lt;int&gt;，需要生成代码！</p>
</li>
<li><p><strong>Error！在main.cpp中只能访问vector.h，但是该文件中没有接口的实现.并且不能找到vector&lt;int&gt;.cpp！</strong></p>
</li>
</ol>
<p>解决：</p>
<pre><code class="cpp">// vector.h
#include “vector.cpp”
template &lt;typename T&gt;
class vector&lt;T&gt; &#123;
 T&amp; at(int i);
&#125;;
</code></pre>
</li>
</ul>
<h2 id="8-Template-Classes-and-Const-Correctness"><a href="#8-Template-Classes-and-Const-Correctness" class="headerlink" title="8. Template Classes and Const Correctness"></a>8. Template Classes and Const Correctness</h2><h3 id="Member-Types"><a href="#Member-Types" class="headerlink" title="Member Types"></a>Member Types</h3><ul>
<li><p>有时我们需要一个依赖于模板类型的类型名称</p>
</li>
<li><pre><code class="cpp">std::vector&lt;int&gt; a = &#123;1, 2&#125;;
std::vector&lt;int&gt;::iterator it = a.begin();
</code></pre>
</li>
<li><p>iterator是vector的一个<strong>成员类型</strong>(member type)</p>
</li>
</ul>
<p>语法：</p>
<pre><code class="cpp">//vector.h
template&lt;typename T&gt; class vector &#123;
    public:
    using iterator = T* // something internal like T*
    iterator begin();
&#125;
</code></pre>
<ul>
<li>旁注：类型别名<ul>
<li>可以在应用代码中使用<code>using type_name = type </code> ！</li>
<li>当在类接口中使用时，它定义了一个嵌套类型，如<code>vector::iterator</code></li>
<li>当将它用在应用程序代码中时(如main.cpp中)，它会在代码作用域中创建<code>type</code>的另一个名字(直到下一个未匹配的})</li>
</ul>
</li>
</ul>
<h3 id="Template-summary"><a href="#Template-summary" class="headerlink" title="Template summary"></a>Template summary</h3><ul>
<li>在.h中的类定义之间添加<code>template&lt;class T1, T2..&gt;</code></li>
<li>在.cpp中的所有函数签名之前添加<code>template&lt;class T1, T2..&gt;</code></li>
<li>当返回向iterator这样的嵌套类型时，将<code>typename ClassName&lt;T1, T2..&gt;::member_type</code>而不只是<code>member_type</code>作为返回类型</li>
<li>模板在被实例化前不会产生(emit)代码，所以将.cpp文件包含到.h文件中，而不是另一种方式！</li>
</ul>
<h3 id="Const-Correctness"><a href="#Const-Correctness" class="headerlink" title="Const Correctness"></a>Const Correctness</h3><ul>
<li><p>definition: const: 关键字，表明一个变量、函数或者形参不能被修改</p>
</li>
<li><p>definition: const-interface: 一个类定义中所有<strong>被标记为const的成员函数</strong>。类型为<code>const ClassName</code>的对象只能使用const-interface</p>
</li>
<li><pre><code class="cpp">const std::string&amp; StrVector::at(size_t index) const &#123;
    return static_cast&lt;const std::string&amp;&gt;(const_cast&lt;StrVector*&gt;(this)-&gt;at(index));
&#125;
</code></pre>
<p>奇特的static_cast&#x2F;const_cast可以让我们重用非const版本函数来实现const版本:</p>
<ol>
<li>对<code>this</code>进行转换，让它指向非const对象</li>
<li>调用函数的非const版本</li>
<li>对函数调用返回的非const返回值进行转换(转换成const值)</li>
</ol>
</li>
<li><p>旁注：static_cast 和 const_cast</p>
<p>static_cast( expression ):</p>
<ul>
<li>被用来从一个类型转换成另一个类型</li>
<li>例如<code> int my_int = static_cast(3.1);</code></li>
<li>当转换会丢失常量性(constness)时不能被使用</li>
</ul>
<p>const_cast( expression ):</p>
<ul>
<li><p>const_cast可以被用来移除常量性</p>
</li>
<li><p>允许你创造对常量对象的非常量指针或引用</p>
</li>
<li><pre><code class="cpp">const int const_int = 3;
int&amp; my_int = const_cast&lt;int&amp;&gt;(const_int);
</code></pre>
</li>
</ul>
</li>
<li><p>const iterator vs const_iterator</p>
<pre><code class="cpp">using iterator = std::string*;
using const_iterator = const std::string*;

const iterator it_c = vec.begin(); //string * const, const ptr to non-const obj
*it_c = &quot;hi&quot;; //OK! it_c is a const pointer to non-const object
it_c++; //not ok! can’t change where a const pointer points!

const_iterator c_it = vec.begin(); //const string*, a non-const ptr to const obj
c_it++; // totally ok! The pointer itself is non-const
*c_it = &quot;hi&quot; // not ok! Can’t change underlying const object
cout &lt;&lt; *c_it &lt;&lt; endl; //allowed! Can always read a const object, just can&#39;t change
//const string * const, const ptr to const obj

const const_iterator c_it_c = vec.begin();
cout &lt;&lt; c_it_c &lt;&lt; &quot; points to &quot; &lt;&lt; *c_it_c &lt;&lt; endl; //only reads are allowed!
c_it_c++; //not ok! can’t change where a const pointer points!
*c_it_c = &quot;hi&quot; // not ok! Can’t change underlying const object
</code></pre>
</li>
<li><p>const and const-correctness summary</p>
<ul>
<li>尽可能多地使用const形参和变量</li>
<li>一个类的每一个不改变它的成员变量的成员函数都应该被标记为const</li>
<li>不要重复造轮子！使用奇特的static_cast&#x2F;const_cast来重用非const版本来实现const版本</li>
<li>auto将丢弃所有const和&amp;，所以一定要指定</li>
<li>为你的所有类制作iterator和const_iterator</li>
</ul>
</li>
</ul>
<h2 id="9-Template-Functions"><a href="#9-Template-Functions" class="headerlink" title="9. Template Functions"></a>9. Template Functions</h2><h3 id="Template-Functions"><a href="#Template-Functions" class="headerlink" title="Template Functions"></a>Template Functions</h3><ul>
<li>definition: 模板函数的功能可以适应多个类型或者类而不用为每一种类型都重复整段代码</li>
<li>基本语法：<pre><code class="cpp">template &lt;typeanme Type=int&gt; //int是默认形参类型
Type myMin(Type a, Type b) &#123;
  return a &lt; b ? a : b;
&#125;
</code></pre>
</li>
<li>调用模板函数<ul>
<li>可以显式指定类型<pre><code class="cpp">cout &lt;&lt; myMin&lt;int&gt;(3, 4) &lt;&lt; endl; //3
</code></pre>
</li>
<li>也可以隐式地将类型留给编译器推断<pre><code class="cpp">cout &lt;&lt; myMin(3.2, 4) &lt;&lt; endl; //3.2
</code></pre>
</li>
</ul>
</li>
<li>跟模板类一样，模板函数在被使用之前不会被编译<ul>
<li>对于不同参数对应的模板实例化，编译器都会生成一个模板的新的特定版本</li>
<li>在编译后就好像你自己手写了每一个版本</li>
</ul>
</li>
</ul>
<h3 id="Template-metaprogramming"><a href="#Template-metaprogramming" class="headerlink" title="Template metaprogramming"></a>Template metaprogramming</h3><ul>
<li>模板可以被用来提升性能<ul>
<li><p>通常代码在运行时运行</p>
</li>
<li><p>在模板元编程的帮助下，代码会在编译时运行一次！</p>
</li>
<li><p>旁注：constexpr</p>
<p>C++中还有其它可以让代码在编译时运行的方式<br>constexpr关键字指定一个常量表达式</p>
<ul>
<li>常量表达式必须立即被初始化并且在编译时运行！</li>
<li>传给常量表达式的参数必须也是常量或者常量表达式</li>
</ul>
<p>变量也可以被声明为constexpr</p>
</li>
</ul>
</li>
</ul>
<h3 id="Introduction-to-Algorithms"><a href="#Introduction-to-Algorithms" class="headerlink" title="Introduction to Algorithms"></a>Introduction to Algorithms</h3><h2 id="10-Functions-and-Lambdas"><a href="#10-Functions-and-Lambdas" class="headerlink" title="10. Functions and Lambdas"></a>10. Functions and Lambdas</h2><h3 id="Functions-and-Lambdas"><a href="#Functions-and-Lambdas" class="headerlink" title="Functions and Lambdas"></a>Functions and Lambdas</h3><ul>
<li><p>Predicate Functions</p>
<p>任何返回布尔值的函数都是谓词，谓词可以有任意数量的形参</p>
</li>
<li><p>Function Pointers</p>
<ul>
<li>函数指针很像其它指针</li>
<li>它们可以像变量作为参数或者在模板函数中被传递</li>
<li>它们可以像函数一样被调用</li>
</ul>
</li>
<li><p>lambdas</p>
<p>lambda是内联的、匿名的函数，它可以知道声明在与它相同作用域中的函数</p>
<ul>
<li><p>捕捉子句：可以捕捉任何外部变量，可以是引用捕捉或者值捕捉</p>
<pre><code class="cpp">[]              //captures nothing
[limit]         //captures limit by value
[&amp;limit]        //captures limit by reference
[&amp;limit,upper]  //captures limit by reference,upperby value
[&amp;, limit]        //captures everything except limit by reference
[&amp;]             //captures everything by reference
[=]             //captures everything by value
</code></pre>
</li>
</ul>
</li>
<li><p>Aside: Functor</p>
<p>functor是提供了()操作符实现的类</p>
</li>
<li><p>Aside: Virtual Functions</p>
</li>
</ul>
<h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><h2 id="11-Operators"><a href="#11-Operators" class="headerlink" title="11. Operators"></a>11. Operators</h2><h3 id="Operators-and-Operator-Overloading"><a href="#Operators-and-Operator-Overloading" class="headerlink" title="Operators and Operator Overloading"></a>Operators and Operator Overloading</h3><ul>
<li>不能重载的操作符：<ul>
<li>Scope Resolution - ::</li>
<li>Ternary - ? </li>
<li>Member Access -  .</li>
<li>Pointer-to-member access  - .*</li>
<li>Object size, type, and casting - sizeof() typeid() cast()</li>
</ul>
</li>
<li>两种重载操作符的方式：<ul>
<li>成员函数<ul>
<li>在你的类的作用域中声明重载操作符</li>
<li>允许使用this指向的成员变量</li>
</ul>
</li>
<li>非成员函数<ul>
<li>在类外声明重载操作符</li>
<li>将左右对象都定义为形参</li>
<li>允许LHS是非类类型(如 double)</li>
<li>允许对不属于我们的类进行重载！(如 vector)</li>
</ul>
</li>
</ul>
</li>
<li>规则与哲学<ul>
<li>当看见被重载的操作符时它的含义应该是明显的</li>
<li>功能应该与对应的算术操作具有合理的相似性</li>
<li>当含义不明显时，给它一个正常的名字来代替(放弃重载)</li>
</ul>
</li>
</ul>
<h2 id="12-Special-Member-Functions"><a href="#12-Special-Member-Functions" class="headerlink" title="12. Special Member Functions"></a>12. Special Member Functions</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>类有三个主要部分：构造器、析构器、成员变量和函数。</p>
<p>构造器在每次新实例被创建时被调用，析构器在实例超出作用域时被调用。</p>
<p>有一些<strong>特殊成员函数</strong> - 每个类默认就拥有它们！</p>
<ul>
<li><p>共有六个特殊成员函数</p>
<p>这些函数只在它们被调用时生成</p>
<ul>
<li>默认构造器</li>
<li>析构器</li>
<li>拷贝构造器</li>
<li>拷贝赋值操作符</li>
<li>移动构造器</li>
<li>移动赋值操作符</li>
</ul>
<p>不必全部把它们写出来，它们都有自动生成的默认版本！</p>
</li>
</ul>
<h3 id="Copy-and-copy-assignment"><a href="#Copy-and-copy-assignment" class="headerlink" title="Copy and copy assignment"></a>Copy and copy assignment</h3><ul>
<li><p>初始化列表</p>
<ul>
<li>初始化列表比起在构造函数内部进行赋值要更有效率</li>
<li>如果变量是不能赋值的类型(non-assignable type)甚至不得不用初始化列表</li>
<li>可以用在任意构造器，甚至是带参数的非默认构造器！</li>
</ul>
</li>
<li><p>为什么重写特殊成员函数？</p>
<p>有时默认特殊成员函数不满足要求！</p>
<ul>
<li>默认情况下拷贝构造器会创造每一个成员变量的拷贝</li>
<li>这是一种<strong>逐成员</strong>的拷贝</li>
<li>这样的拷贝不总是满足要求</li>
</ul>
</li>
</ul>
<h3 id="Default-and-delete"><a href="#Default-and-delete" class="headerlink" title="Default and delete"></a>Default and delete</h3><ul>
<li>规则0：如果编译器生成的默认情况下的特殊成员函数符合代码逻辑的话，就不要自己写了</li>
<li>规则3：如果要定义<strong>析构器，拷贝构造器，拷贝赋值运算符</strong>中的一个，就应该把三者都定义了！</li>
</ul>
<h3 id="Move-and-move-assignment"><a href="#Move-and-move-assignment" class="headerlink" title="Move and move assignment"></a>Move and move assignment</h3><ul>
<li>移动构造器和移动赋值操作符会进行“逐成员移动“</li>
<li>定义一个移动赋值操作符防止移动拷贝构造器的产生</li>
</ul>
<h2 id="13-Move-Semantics"><a href="#13-Move-Semantics" class="headerlink" title="13. Move Semantics"></a>13. Move Semantics</h2><h3 id="L-values-vs-r-values"><a href="#L-values-vs-r-values" class="headerlink" title="L values vs r values"></a>L values vs r values</h3><p><img src="/..%5Cimages%5CCS106L%5C13.1.%E5%B7%A6%E5%80%BCvs%E5%8F%B3%E5%80%BC.png" alt="13.1.左值vs右值"></p>
<p><strong>左值存活到作用域的末尾，而右值存活到行的末尾。</strong></p>
<h3 id="What-the-heck-is-amp-amp"><a href="#What-the-heck-is-amp-amp" class="headerlink" title="What the heck is &amp;&amp;??"></a>What the heck is &amp;&amp;??</h3><ul>
<li><p>std::move</p>
<ul>
<li><p><code>std::move(x) </code>只是将x转换成一个右值</p>
</li>
<li><p>它是一种强迫C++选择一个函数的&amp;&amp;版本的方式</p>
</li>
<li><p>什么时候使用它？</p>
<p>经验法则：</p>
<ul>
<li>Wherever we take in a const &amp; parameter in a class member function and assign it to something else in our function</li>
<li>Don’t use std::move outside of class definitions, never use it in application code!</li>
</ul>
</li>
</ul>
</li>
<li><p>TLDR: Move Semantics</p>
<ul>
<li>如果你的类定义了拷贝构造函数和拷贝赋值，你也应该定义移动构造函数和移动赋值</li>
<li>使用std::move来强迫其它类型的移动赋值和构造器的使用</li>
<li>**std::move(x)**做的就是将x转成右值</li>
<li>防止**std::move(x)**出现在主函数代码中！</li>
</ul>
</li>
</ul>
<h3 id="关于SMF的一些哲学"><a href="#关于SMF的一些哲学" class="headerlink" title="关于SMF的一些哲学"></a>关于SMF的一些哲学</h3><ul>
<li>三条引导规则<ul>
<li>零的规则<ul>
<li>如果可以避免定义默认操作，就避免吧</li>
<li>为什么？因为这样具有最简单明了的语义</li>
</ul>
</li>
<li>三的规则<ul>
<li>如果需要实现自定义的析构器，你几乎是一定要定义拷贝构造器和拷贝赋值操作符的</li>
<li>为什么？因为你很可能因为某种原因在进行内存管理，所以默认提供的浅拷贝不能良好地工作</li>
</ul>
</li>
<li>五的规则<ul>
<li>如果定义了自定义拷贝构造器&#x2F;赋值操作符，你也应该定义移动构造器&#x2F;赋值操作符</li>
<li>为什么？这与正确性无关但是关系到效率。进行额外的拷贝效率太低了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于移动语义的几篇文章"><a href="#关于移动语义的几篇文章" class="headerlink" title="关于移动语义的几篇文章"></a>关于移动语义的几篇文章</h3><p><a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/summerhust/article/details/110677472">https://blog.csdn.net/summerhust/article/details/110677472</a></p>
<h2 id="14-std-optional-and-Type-Safety"><a href="#14-std-optional-and-Type-Safety" class="headerlink" title="14. std::optional and Type Safety"></a>14. std::optional and Type Safety</h2><h3 id="Introducing-std-optional"><a href="#Introducing-std-optional" class="headerlink" title="Introducing std::optional"></a>Introducing std::optional</h3><p><strong>std::optional</strong>是一个模板类，它要么包含一个类型T的值，要么什么也不包含(被表示为<strong>nullopt</strong>)</p>
<h2 id="15-RAII-Smart-Pointers-and-Building-C-Projects"><a href="#15-RAII-Smart-Pointers-and-Building-C-Projects" class="headerlink" title="15. RAII, Smart Pointers, and Building C++ Projects"></a>15. RAII, Smart Pointers, and Building C++ Projects</h2><h3 id="RAII-A-coding-standard-and-practice"><a href="#RAII-A-coding-standard-and-practice" class="headerlink" title="RAII - A coding standard and practice"></a>RAII - A coding standard and practice</h3><ul>
<li><p>识别代码路径</p>
<p>Code path: 计算机能看到的代码的一次运行路径</p>
</li>
<li><p>RAII - Resource Acquisition is Initialization</p>
<ul>
<li>一个类使用的所有资源应该在构造器中进行请求</li>
<li>一个类使用的所有资源应该在析构器中进行释放</li>
</ul>
</li>
<li><p>为什么要RAII？</p>
<ul>
<li>对象在创建后应该立即可以投入使用</li>
<li>不应该出现一个对象的“半有效”状态，即对象存在于内存中，但是不能被程序访问&#x2F;使用的状态</li>
<li>析构器总是会被调用，所以资源总是会被释放！</li>
</ul>
</li>
<li><p>对于内存来说RAII如何遵守？</p>
<p><strong>避免显式地调用new和delete</strong></p>
<p>建议使用make_unique来代替</p>
</li>
</ul>
<h3 id="Smart-Pointers"><a href="#Smart-Pointers" class="headerlink" title="Smart Pointers"></a>Smart Pointers</h3><ul>
<li><p>三种智能指针</p>
<ul>
<li><p><strong>std::unique_ptr</strong></p>
<p>独自拥有它的资源，不能被拷贝</p>
</li>
<li><p><strong>std::shared_ptr</strong></p>
<p>可以创造拷贝，当底层内存超出作用域时被破坏</p>
</li>
<li><p><strong>std::weak_ptr</strong></p>
<p>建模临时的拥有权：当一个对象只需要在它存在时被访问，<strong>weak_ptr</strong>是一个对象的观察者，而不是拥有者！</p>
</li>
</ul>
</li>
<li><p>经验法则</p>
<p>初始化智能指针：</p>
<p><img src="C:\Users\chen2\Desktop\files\cyccycyy.github.io\source\images\CS106L\16.1.智能指针初始化.png" alt="16.1.智能指针初始化"></p>
<ul>
<li>总是使用std::make_unique 和 std::make_shared!<ul>
<li>如果我们不用make_shared，那么我们就会分配两次内存(一次分配给sp, 一次分配给new T)</li>
<li>对于智能指针我们应该保持一致 - 如果使用make_shared，也要使用make_unique!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Building-C-Projects"><a href="#Building-C-Projects" class="headerlink" title="Building C++ Projects"></a>Building C++ Projects</h3><p>编译器定义：编译器就是任意将代码从一门语言翻译成另一门语言的<strong>程序</strong></p>
<p>编译器的四个主要阶段：</p>
<p>preprocessing -&gt; Compilation -&gt; Assembly -&gt; Linking </p>
<ul>
<li><p>preprocessing </p>
<p>在这一阶段，代码在编译前被清理</p>
<ul>
<li>所有预处理命令被执行</li>
<li>注释和多余的空白符被清理</li>
</ul>
<p><strong>main.cpp</strong></p>
</li>
<li><p>Compilation</p>
<p>这一阶段涉及到汇编的实际翻译</p>
<ul>
<li>C++代码被转换成汇编代码</li>
<li>原本就用汇编写的代码可以保持不变！</li>
<li>汇编特定于机器的体系结构</li>
</ul>
<p>此时代码仍然可以供人类阅读</p>
<p><strong>main.cpp -&gt; main.asm</strong></p>
</li>
<li><p>Assembly </p>
<p>在这里，汇编器将汇编代码转换成目标代码(object code)</p>
<ul>
<li>目标代码是处理器执行的真正的机器可读代码(即二进制代码)</li>
<li>汇编代码是人类可读的，可以将机器指令映射成我们可以理解的某些东西</li>
</ul>
<p>汇编器独立地转换每一个文件&#x2F;程序的每一片；它们还没有被合适地结合成一个程序</p>
<p><strong>main.cpp -&gt; main.asm -&gt; main.o</strong></p>
</li>
<li><p>Linking </p>
<p>链接器接收每一块目标代码并且将它们整合成一个程序</p>
<ul>
<li>独立地文件按顺序被“缝”到一起</li>
<li>符号被填入，所以函数可以被调用、变量可以跨文件引用</li>
</ul>
<p>最终我们有了可执行程序</p>
<p><strong>main.cpp -&gt; main.asm -&gt; main.o -&gt; main</strong></p>
</li>
</ul>
<p>make和Makefiles做什么？</p>
<ul>
<li>make是一个帮助你编译的“构建系统”程序</li>
<li>它使用g++作为它的主引擎</li>
<li>它可以通过创建一个被称作Makefile的配置文件来被使用</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/06/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ETreeMap%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/" title="记一次关于TreeMap的使用的坑"><span class="has-text-weight-semibold">下一页: 记一次关于TreeMap的使用的坑</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="fertfest/fertfest.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fertfest"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> fertfest 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>清醒时做事，迷茫时读书，独处时思考，烦躁时运动，焦虑时行动，得意时淡然，失意时坦然，忙碌时专注，闲暇时蓄力。</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>